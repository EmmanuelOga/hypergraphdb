When Java is used to access a HyperGraph, the implementation provides facilities for automatically creating HyperGraph types based on Java classes. We say that the implementation infers a HyperGraph based on a Java class. This is possible because of the reflective capabilities of Java.

The mapping between Java class and HyperGraph types is based mainly on the Java beans. By a widely used and accepted naming convention, Java beans are employed as the basic record structure in that language and most data models in Java are developed using this convention. A Java bean is represented in HyperGraph as a Record where each bean property is represented as a Slot.

The mapping between HyperGraph types and Java extends further to Java abstract classes and interfaces. Each abstract class or interface is represented as a HyperGraph HGAbstractType. As noted above, abstract types in HyperGraph are uncapable of creating or storing actual instances. Instead, they serve the purpose of semantic tags and participate in an inheritance hierarchy. For the purposes of the Java-HyperGraph type mapping, interfaces are treated as classes with only abstract methods.

The HyperGraph Java API allows one to add an atom to the DB by passing a generic Java Object instance. The implementation will treat that instance as a Java bean and subsequently return an instance of that in all queries returning the atom. The database format, as defined by the type layout, is language agnostic and records that are bound to Java beans may be read and written from a different language (e.g. C++) without a problem.