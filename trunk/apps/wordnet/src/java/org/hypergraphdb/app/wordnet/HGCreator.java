package org.hypergraphdb.app.wordnet;  import net.didion.jwnl.JWNL;import net.didion.jwnl.JWNLException;import net.didion.jwnl.data.*;import net.didion.jwnl.dictionary.Dictionary;import java.io.FileInputStream;import java.util.*;import org.hypergraphdb.HGHandle;import org.hypergraphdb.app.wordnet.data.AdjExcLink;import org.hypergraphdb.app.wordnet.data.AdjSynsetLink;import org.hypergraphdb.app.wordnet.data.AdverbExcLink;import org.hypergraphdb.app.wordnet.data.AdverbSynsetLink;import org.hypergraphdb.app.wordnet.data.ExcLink;import org.hypergraphdb.app.wordnet.data.NounExcLink;import org.hypergraphdb.app.wordnet.data.NounSynsetLink;import org.hypergraphdb.app.wordnet.data.PtType;import org.hypergraphdb.app.wordnet.data.SynsetLink;import org.hypergraphdb.app.wordnet.data.VerbExcLink;import org.hypergraphdb.app.wordnet.data.VerbFrameLink;import org.hypergraphdb.app.wordnet.data.VerbSynsetLink;import org.hypergraphdb.atom.HGTypeStructuralInfo;import org.hypergraphdb.handle.*;import org.hypergraphdb.HGIndex;import org.hypergraphdb.HGLink;import org.hypergraphdb.HGPersistentHandle;import org.hypergraphdb.HGQuery;import org.hypergraphdb.HGSearchResult;import org.hypergraphdb.HGTypeSystem;import org.hypergraphdb.HGValueLink;import org.hypergraphdb.HyperGraph;import org.hypergraphdb.query.AtomPartCondition;import org.hypergraphdb.query.AtomTypeCondition;import org.hypergraphdb.query.AtomValueCondition;import org.hypergraphdb.query.ComparisonOperator;import org.hypergraphdb.query.HGQueryCondition;import org.hypergraphdb.query.impl.PredicateBasedFilter;import org.hypergraphdb.query.impl.SearchableBasedQuery;import org.hypergraphdb.storage.DefaultIndexImpl;import org.hypergraphdb.type.HGAtomType;import org.hypergraphdb.type.RecordType;//import org.hypergraphdb.viewer.HGViewerInit;import org.hypergraphdb.viewer.hg.HGUtils;public class HGCreator{	private static final String JWNL_PROPERTIES_FILE = "D:\\kosta\\hg\\jwnl\\file_properties.xml";	private static HyperGraph hg;	private static final String PATH = "D:\\kosta\\hg\\nouns";	final static POS[] pos = new POS[] { POS.NOUN, POS.VERB, POS.ADVERB,			POS.ADJECTIVE };	final static String[] synset_alias = new String[] { "NounSynset",			"VerbSynset", "AdverbSynset", "AdjSynset" };	static Map posToInd = new HashMap();	final static Class[] synset_link_classes = new Class[] {			NounSynsetLink.class, VerbSynsetLink.class, AdverbSynsetLink.class,			AdjSynsetLink.class };	static int n_exc = 0;	static long n_syn = 0;	static long n_point = 0;	static long n_word = 0;	static long n_vlinks = 0;	public static void main(String[] args) 	{		/*		 * 		 * if (args.length != 1) { System.out.println(USAGE); System.exit(-1); }		 * 		 */		String propsFile = JWNL_PROPERTIES_FILE;// args[0];		try		{			// initialize JWNL (this must be done before JWNL can be used)			JWNL.initialize(new FileInputStream(propsFile));			// this should go after JWNL.initialize			for (int i = 0; i < pos.length; i++)				posToInd.put(pos[i], new Integer(i));			populateDB();			System.out.println("Total words: " + n_word);			System.out.println("Total synsets: " + n_syn);			System.out.println("Total pointers: " + n_point);			System.out.println("Total exceptions: " + n_exc);			System.out.println("Total verb frame links: " + n_vlinks);			System.out.println("Total verb frames: "					+ VerbFrame.getVerbFramesSize());			// populateMinDB();			// testDB();		}		catch (Exception ex)		{			ex.printStackTrace();			hg.close();			System.exit(-1);		}		hg.close();		System.exit(0);	}	private static void populateMinDB() throws JWNLException	{		hg = new HyperGraph(PATH + "Min");		createIndexes();		Dictionary d = Dictionary.getInstance();		// for(int i = 0; i < pos.length; i++)		// addWords(hg, d.getIndexWordIterator(pos[i]));		// System.out.println("adding words done.");		IndexWord DOG = d.getIndexWord(POS.NOUN, "dog");		Arrays.asList(DOG.getSenses()).iterator();		addSynsets(hg, Arrays.asList(DOG.getSenses()).iterator(), 0);		addPointers(hg, Arrays.asList(DOG.getSenses()).iterator());		// addVerbFrames(hg);		// for(Iterator it = d.getSynsetIterator(POS.VERB); it.hasNext();)		// connectSynsetVerbFrames(hg, (Synset) it.next());		System.out.println("DONE. ");		// hg.close();	}	private static void testDB() throws JWNLException	{		hg = new HyperGraph(PATH);		org.hypergraphdb.app.wordnet.data.Word word = new org.hypergraphdb.app.wordnet.data.Word(				"dog");		HGHandle h = hg.getHandle(word);		h = lookup("word", "lemma", word.getLemma());		System.out.println("DOG handle: " + h);		System.out.println("DOG word: " + hg.get(h));		if (h == null) return;		HGHandle[] links = hg.getIncidenceSet(h);		System.out.println("links: " + links.length);		for (int i = 0; i < links.length; i++)		{			HGLink link = (HGLink) hg.get(links[i]);			System.out.println("Link: " + link);			HGHandle[] rels = hg.getIncidenceSet(links[i]);			System.out.println("       Relations: " + rels.length);			for (int jj = 0; jj < rels.length; jj++)				System.out.println("    Relation: " + hg.get(rels[jj]));			for (int j = 0; j < link.getArity(); j++)				System.out.println("Targets: " + hg.get(link.getTargetAt(j)));		}		// hg.close();	}	private static void createIndexes()	{		HGPersistentHandle typeH = hg.getPersistentHandle(hg.getTypeSystem()				.getTypeHandle(org.hypergraphdb.app.wordnet.data.Word.class));		hg.getTypeSystem().addAlias(typeH, "word");		hg.createIndex(typeH, new String[] { "lemma" });		for (int i = 0; i < pos.length; i++)		{			typeH = hg.getPersistentHandle(hg.getTypeSystem().getTypeHandle(					synset_link_classes[i]));			hg.getTypeSystem().addAlias(typeH, synset_alias[i]);			hg.createIndex(typeH, new String[] { "gloss" });		}		typeH = hg.getPersistentHandle(hg.getTypeSystem().getTypeHandle(				org.hypergraphdb.app.wordnet.data.VerbFrame.class));		hg.getTypeSystem().addAlias(typeH, "frame");		hg.createIndex(typeH, new String[] { "text" });		System.out.println("Creating synset indexes done.");		/*		 * 		 * for(Iterator it = PtType.getAllPointerTypes().iterator();		 * 		 * it.hasNext();) { PtType type = (PtType) it.next(); typeH =		 * 		 * hg.getPersistentHandle(		 * 		 * hg.getTypeSystem().getHandle(type.getClazz()));		 * 		 * hg.getTypeSystem().addAlias(typeH, type.getLabel());		 * 		 * hg.createIndex(typeH , new String[] {"dbIndex"}); }		 * 		 */	}	private static void populateDB() throws JWNLException	{		hg = new HyperGraph(PATH);		createIndexes();		Dictionary d = Dictionary.getInstance();		for(int i = 0; i < pos.length; i++)		 addWords(hg, d.getIndexWordIterator(pos[i]));		 System.out.println("adding words done.");		 for (int i = 0; i < pos.length; i++) {		  addSynsets(hg, d.getSynsetIterator(pos[i]), i);		 //Sstem.out.println("adding synsets part: " + i);		  }		  System.out.println("adding synsets done."); //		 		for (int i = 0; i < pos.length; i++)			addPointers(hg, d.getSynsetIterator(pos[i]));		System.out.println("adding pointers done.");		addVerbFrames(hg);		for (Iterator it = d.getSynsetIterator(POS.VERB); it.hasNext();)			connectSynsetVerbFrames(hg, (Synset) it.next());		for (int i = 0; i < pos.length; i++)			addExceptions(hg, d.getExceptionIterator(pos[i]), i);		System.out.println("DONE. ");	}	private static void addWords(HyperGraph hg, Iterator it)	{		HGAtomType type = hg.getTypeSystem().getAtomType(				org.hypergraphdb.app.wordnet.data.Word.class);		// int i = 0;		while (it.hasNext())		{			IndexWord word = (IndexWord) it.next();			// System.out.println("addWord " + i++ + ":" + word.getLemma());			hg.add(new org.hypergraphdb.app.wordnet.data.Word(word.getLemma())); // ,			// type);		}	}	private static void addSynsets(HyperGraph hg, Iterator it, int pos)	{		while (it.hasNext())		{			makeSynsetLinkHandle(hg, (Synset) it.next(), pos);			// System.out.println(n_syn);		}		// System.out.println(n_syn++);	}	private static HGHandle makeSynsetLinkHandle(HyperGraph hg, Synset syn,			int pos)	{		Word[] words = syn.getWords();		HGHandle[] targets = new HGHandle[words.length];		for (int i = 0; i < words.length; i++)		{			targets[i] = getWordHandle(hg, words[i].getLemma(), true);		}		SynsetLink link = createSynsetLink(syn);		link.setTargets(targets);		HGHandle sh = hg.getHandle(link);		if (sh == null)		{			sh = lookup(synset_alias[pos], "gloss", syn.getGloss());			if (sh != null) return sh;			sh = hg.add(link);			n_syn++;			// System.out.println("Adding synset: " + link.getArity() + ":" +			// syn);		}		return sh;	}	private static SynsetLink createSynsetLink(Synset syn)	{		SynsetLink link = null;		if (syn.getPOS().equals(POS.ADJECTIVE))			link = new AdjSynsetLink();		else if (syn.getPOS().equals(POS.ADVERB))			link = new AdverbSynsetLink();		else if (syn.getPOS().equals(POS.NOUN))			link = new NounSynsetLink();		else if (syn.getPOS().equals(POS.VERB)) link = new VerbSynsetLink();		link.setGloss(syn.getGloss());		return link;	}	private static void addPointers(HyperGraph hg, Iterator it)			throws JWNLException	{		PtType.initialize();		while (it.hasNext())		{			Synset syn = (Synset) it.next();			Pointer[] ps = syn.getPointers();			for (int i = 0; i < ps.length; i++)			{				n_point++;				org.hypergraphdb.app.wordnet.data.Pointer hg_p = makePointer(ps[i]);				if (hg_p != null)				{					// System.out.println("" + n_point);					hg.add(hg_p);				} else				{					throw new NullPointerException("!!!!!!!NULL Pointer: "							+ ps[i]);				}				//System.out.println("" + n_point + "addPointer: " + hg_p);			}		}		// System.out.println("Total pointers: " + n_point);	}	private static void addExceptions(HyperGraph hg, Iterator it, int pos)	{		while (it.hasNext())		{			Exc exc = (Exc) it.next();			String[] excs = exc.getExceptionArray();			HGHandle[] targets = new HGHandle[excs.length + 1];			targets[0] = getWordHandle(hg, exc.getLemma(), true);			for (int i = 0; i < excs.length; i++)			{				targets[i + 1] = getWordHandle(hg, excs[i], true);			}			hg.add(createExcLink(targets, pos));			n_exc++;		}	}	// POS.NOUN, POS.VERB, POS.ADVERB,POS.ADJECTIVE	private static ExcLink createExcLink(HGHandle[] targets, int pos)	{		ExcLink link = null;		if (pos == 0)			link = new NounExcLink();		else if (pos == 1)			link = new VerbExcLink();		else if (pos == 2)			link = new AdverbExcLink();		else if (pos == 3) link = new AdjExcLink();		link.setTargets(targets);		return link;	}	private static org.hypergraphdb.app.wordnet.data.Pointer makePointer(			Pointer p) throws JWNLException	{		// System.out.println("makePointer: " + p + " : " +		// p.getType().getKey());		if (PtType.getPointerTypeForKey(p.getType().getKey()) == null)		{			// temp_check(p);			return null;		}		Class clazz = PtType.getPointerTypeForKey(p.getType().getKey())				.getClazz();		org.hypergraphdb.app.wordnet.data.Pointer hg_p = null;		try		{			hg_p = (org.hypergraphdb.app.wordnet.data.Pointer) clazz					.newInstance();		}		catch (Exception ex)		{			ex.printStackTrace();			throw new RuntimeException(					"Could not instantiate pointer with class: " + clazz);		}		int src_index = 0;		if (p.isLexical()) src_index = ((Word) p.getSource()).getIndex();		// System.out.println("Indexes: " + src_index + " target: " +		// p.getTargetIndex());		hg_p.setSourceIndex(src_index);		hg_p.setTargetIndex(p.getTargetIndex());		HGHandle[] ptrTargets = new HGHandle[2];		/*		 * 		 * System.out.println("Pointer: " + p.getType().getLabel() + ":" +		 * p.getSource().getClass().getName() + " source: " + p.getSource());		 * 		 * System.out.println("Pointer: " + p.getTarget().getClass().getName() + "		 * target: " + p.getTarget()); //		 */		Synset s = getSynsetForPointerTarget(p.getSource());		ptrTargets[0] = makeSynsetLinkHandle(hg, s, ((Integer) posToInd.get(s				.getPOS())).intValue());		Synset s1 = getSynsetForPointerTarget(p.getTarget());		ptrTargets[1] = makeSynsetLinkHandle(hg, s1, ((Integer) posToInd.get(s1				.getPOS())).intValue());		if (ptrTargets[1] == null || ptrTargets[0] == null)			throw new NullPointerException("NULL target: " + ptrTargets);		hg_p.setTargets(ptrTargets);		return hg_p;	}	private static Synset getSynsetForPointerTarget(PointerTarget p)	{		if (p instanceof Synset) return (Synset) p;		return ((Word) p).getSynset();	}	private static HGHandle getWordHandle(HyperGraph hg, String lemma,			boolean search_db)	{		org.hypergraphdb.app.wordnet.data.Word hg_word = new org.hypergraphdb.app.wordnet.data.Word(				lemma);		HGHandle h = hg.getHandle(hg_word);		if (h == null && search_db)		{			h = lookup("word", "lemma", lemma);			if (h != null)			{				return h;			}		}		if (h == null)		{			// TODO: these are non-index words, maybe we should mark them as			// such			h = hg.add(hg_word);			System.out.println("" + n_word + " Adding word: " + hg_word);			++n_word;		}		return h;	}	private static void addVerbFrames(HyperGraph hg)	{		for (int i = 1; i <= VerbFrame.getVerbFramesSize(); i++)		{			hg.add(new org.hypergraphdb.app.wordnet.data.VerbFrame(VerbFrame					.getFrame(i), i));		}	}	private static HGHandle makeVerbFrameHandle(HyperGraph hg, int i)	{		org.hypergraphdb.app.wordnet.data.VerbFrame frame = new org.hypergraphdb.app.wordnet.data.VerbFrame(				VerbFrame.getFrame(i), i);		HGHandle h = hg.getHandle(frame);		if (h != null) return h;		h = lookup("frame", "text", frame.getText());		if (h != null) return h;		h = hg.add(frame);		return h;	}	private static void connectSynsetVerbFrames(HyperGraph hg, Synset syn)	{		BitSet bs = syn.getVerbFrameFlags();		int[] fr_inds = VerbFrame.getVerbFrameIndicies(bs);		HGHandle[] targets = new HGHandle[2];		for (int i = 0; i < fr_inds.length; i++)		{			targets[0] = makeVerbFrameHandle(hg, fr_inds[i]);			targets[1] = makeSynsetLinkHandle(hg, syn, 1);			VerbFrameLink link = new VerbFrameLink(targets);			hg.add(link);			n_vlinks++;		}	}	public static HGPersistentHandle lookup(String typeAlias,			String keyProperty, String keyValue)	{		HGHandle typeHandle = hg.getTypeSystem().getTypeHandle(typeAlias);		HGIndex index = hg.getIndex(typeHandle, new String[] { keyProperty });		if (index == null)		{			// hg.createIndex(typeHandle, new String[] {keyProperty});			index = hg.getIndex(typeHandle, new String[] { keyProperty });		}		return (HGPersistentHandle) index.findFirst(keyValue);	}		public static void addHGTypeStructuralInfo(HyperGraph hg)	{		for(Class c: getDirLinks())		{			HGAtomType type = hg.getTypeSystem().getAtomType(c);			HGTypeStructuralInfo info = new HGTypeStructuralInfo(					hg.getPersistentHandle(hg.getHandle(type)), 2, true);			hg.add(info);		}	}	private static Set<Class> dir_links = null;	private static Set<Class> getDirLinks()	{		if (dir_links != null) return dir_links;		dir_links = new HashSet<Class>();		ClassLoader cl = HGCreator.class.getClassLoader(); //HGViewerInit.getClassLoader();		try		{			dir_links.add(cl					.loadClass("org.hypergraphdb.app.wordnet.data.Pointer"));			dir_links.add(cl					.loadClass("org.hypergraphdb.app.wordnet.data.ExcLink"));			dir_links.add(cl					.loadClass("org.hypergraphdb.app.wordnet.data.VerbFrameLink"));		}		catch (Exception ex)		{			ex.printStackTrace();		}		return dir_links;	}}