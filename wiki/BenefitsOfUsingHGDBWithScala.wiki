#summary Benefits of using HyperGraphDB with Scala

_Disclaimer: this is user-created content and not an official HyperGraphDB document._ *Under construction*

This Document is be organized as follows:
  * 1) ShortDemo
  * 2) Intro to scala
  * 3) Commented scala code implementing Short Demo.
  * 4) Interesting scala features

=1.ShortDemo =
{{{
val a = graph.put("hallo Welt")  
                                 // like graph.add but returning TypedHandle parametrized to String

println(a.replaceAll("hallo", "hello").replaceAll("Welt", "World")) 
                                 // prints "hello World" 
                                 // hence calling String methods directly on that typedhandle
                                 // as if it was the dereferenced java object itself

  val inc2 =  hg.findAll(graph, hg.incident("asdf"))
                                 // use objects where HGHandle are required


//
// the following is currently being tested
//

val otherWorld = a.traverse.find(pair => pair.getFirst.d[String].contains("World"))                          
                                 // starting a traversal from a,
                                 // using defaults parameters (HGlink, same type etc),
                                 // find first occurence of "World".
                                 // Since traversal returns Pair of regular HGHandles,
                                 // d[T] explicitely dereferences and casts it to T

val otherWorldtoUpper = a.traverse(linkConstraint = new AtomTypeCondition(myRelationTypeHandle)).map(p => p.getFirst.d[String].toUpperCase)

                                 // overriding any of named default params
                                 // mapping a traversal result 

val intersects = a.traverse(dfs = true).toSet.intersect(a.traverse(dfs=false).toSet)
                                 // intersecting two traversals.
a.update 
                                 // updating changes of a into HyperGraph

}}}


=2. Intro to Scala=
HyperGraphDB being written in Java is also directly usable by other JVM-languages such as Scala. Scala is a statically-typed, advanced but mature OO-functional-hybrid language. It allows writing very concise and elegant code, and is fully compatible with Java, but offers numerable possibilities absent in Java, such as functions as first-class objects. Using a mechanism called implicit conversions, scala can extend existing code on-demand, i.e. add methods to classes and interconvert types, without requiring any change to the extended classes. Scala is interesting not only as a everyday JVM-frontend that dramatically reduces java boilerplate, but also represents a powerful but low-risk tool to use and adapt hypergraphDB in new ways.


=3. Explanations and commented scala implementation=
A HGHandle is similar to a Java object reference: it is a pointer to some data stored in memory or on disk. Although HypergraphDB atoms are strictly typed, hghandles themselves are not typed in the java world. Furthermore, since hypergraphDB does some sophisticated form of serialization, objects obtained by graph.get(somehandle) have to be cast to their respective type. 
The following hacks aim to add intuitive usage patterns, for example by treating handles as java objects (and vice versa if required).
This is achieved by introducing a class _TypedHandle_ which is simply parametrized by the type of the object that it references. Using three equally simple implicit conversions:
a) the HyperGraph class is extended to provide two methods which create/accept TypedHandle instances. 
b) TypedHandle instances are converted to the objects they references.
c) Any object can be converted to HGHandle instances, which are accepted by hypergraphDB methods requiring handles.

{{{
class TypedHandle[T](@BeanProperty val handle:HGHandle) extends HGPersistentHandle {
  def toByteArray = handle.getPersistent.toByteArray
  def toStringValue = handle.getPersistent.toStringValue
  def compareTo(p1: HGPersistentHandle) = handle.getPersistent.compareTo(p1)
  def getPersistent = handle.getPersistent
}

// following Test object contains the required implicit conversions, which must be in scope:

object Test extends App{
  implicit val graph = // get your HyperGraph instance here.

//
// IMPLICIT CONVERSIONS
//

// extending HyperGraph with two methods for RichHandles:
  implicit def hypergraph2richhypergraph(graph: HyperGraph) = new {
    def put[T](someObject: T): TypedHandle[T] = new TypedHandle[T](graph.add(someObject))
    def gety[T](richHandle:TypedHandle[T]):T = graph.get(richHandle).asInstanceOf[T] //richHandle.d(graph)
  }

// conversion of TypedHandle[T] to T:
  implicit def handle2T[T](handle:TypedHandle[T])(implicit graph:HyperGraph):T = graph.get(handle).asInstanceOf[T]

//hacks on HGHandle
 implicit def richHandle[T](handle:HGHandle)(implicit graph :HyperGraph, ev:Manifest[HGHandle]) = new {
    def sameType:java.util.List[HGHandle] = hg.findAll[HGHandle](graph, new AtomTypeCondition(ev.erasure))
    def sameTypeAnd(queryCondition: HGQueryCondition):java.util.List[HGHandle] = hg.findAll[HGHandle](graph, hg.and(new AtomTypeCondition(ev.erasure), queryCondition))
    def traverse (linkConstraint:HGQueryCondition = new AtomTypeCondition(classOf[HGLink]), atomConstraint:HGQueryCondition= new AtomTypeCondition(classOf[String]), returnPreceeding: Boolean = false, returnSucceeding: Boolean = true, reverseOrder: Boolean = false, dfs: Boolean = true):HGTraversal = {
      val alGen: HGALGenerator = new DefaultALGenerator()//new DefaultALGenerator(graph, linkConstraint, atomConstraint,returnPreceeding, returnSucceeding, reverseOrder)
      val trav: HGTraversal = if (dfs) new HGDepthFirstTraversal(handle, alGen) else new HGBreadthFirstTraversal(handle, alGen)
      trav
    }
    def incidentLinks:java.util.List[HGHandle] = hg.findAll[HGHandle](graph, hg.incident(handle))
    def targets:java.util.List[HGHandle]= hg.findAll[HGHandle](graph, hg.target(handle))
    def isOfType[T]:Boolean = graph.getTypeSystem.getAtomType(handle).getClass.equals(classOf[T])
    //def lowerThanThis(path:String):java.util.List[HGHandle]=  
    def d[T]:T = graph.get(handle).asInstanceOf[T]
  }

// conversion of T to HGHandle
implicit def any2handle[T](any:Any)(unique: Boolean = false)(implicit graph:HyperGraph):HGHandle = try {graph.getHandle(any) }  catch {case _ => if (!unique) graph.add(any) else hg.assertAtom(graph, any)}



graph.close
}
}}}


=4. Interesting scala features=
==Functions as first-class objects==
In scala functions are first-class objects, they can be passed in as argument and returned as result of a method or another function. Methods can be converted to function objects on demand.
Scala's standard collection liberary provides map, flatmap, filter, foreach, forall, groupBy  among many other. These are prominent examples of higher-order-functions and a well-known example of an extremely useful feature that is missing in java. They can be used on Java Collections, Iterators or Iterables, hence they can be used everywhere with HyperGraphDB, given just one import ("import collection.JavaConversions._"). 
Using closures, control structures and operators can be implemented
in a few minutes, such as automatic resource managment i.e. "with
(resource) do (function)". Since in scala there are no operators, just methods, you could also write "Âµ someStream | function"


==Haskell-style pattern matching==
Scala allows pattern matching as found in functional languages, during which variables are bound to parts of deconstructed objects. For example:
{{{
List(1,2,3,4) match { case List(_,a,_,b) if a < b  => println("hello "
+ a); case _ => println("not found");}
//=> "hello 2"
}}}
By providing compagnion objects with extractor methods, existing code can participate in such deep matches, again without touching the extended code.

==for comprehensions==
for comprehensions are more than syntactic sugar for higher-order-functions, they also allow for very comfortable usage of advanced constructs such as monads, functors and applicatives functors. They can be used with (java) collection directly.
{{{
val result =  for( e <- employees;
                        if e.age > 25;
                        salary = e.age * 100;

                  c <- companies;
                        if c.region == "DA";
                        if c.name == e.companyName;
                        if c.avgSalary < salary
                )
            yield ( e.name, c.name, salary - c.avgSalary )
// result is now a List of Tuple(Employe, Compagnie, SalaryExtra)
}}}


- the upcoming scala release 2.10 introduces macros for code generation, and
a new reflection system that provides "mirrors", ie provides access to
the exact same thing that the compiler sees.

- Scala's typesystem has [http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala higher-kinded types], i.e. it can accomodate HGDBs type constructors of type constructors of type constructors...

- more advanced things supposed to be more profoundly useful:
ad-hoc-polymorphism /typeclasses, monads, functors, applicatives

- it's stable but still under active development. It's been choosen in several academic research groups due to the expressive power of it's sophisticated type system.