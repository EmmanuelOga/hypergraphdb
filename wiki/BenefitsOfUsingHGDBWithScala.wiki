#summary Benefits of using HyperGraphDB with Scala

_Disclaimer: this is user-created content and not an official HyperGraphDB document._ *Under construction*

Index
  * 1) Intro 
  * 2) ShortDemo
  * 3) Commented scala code implementing ShortDemo.


=1. Intro=
HyperGraphDB is directly usable by other JVM-languages such as Scala. Scala is interesting not only as an everyday JVM-frontend that dramatically reduces java boilerplate i.e. by implicit parameters, but also provides a versatile, powerful but no-risk toolset to use and easily adapt hypergraphDB in completely new ways, beyond mere syntactic sugar. 
For a more detailed introduction into scala and interesting features, checkout [http://scalahypergraph.blogspot.de/2012/07/interesting-scala-features.html this blogpost] written with hypergraphDB in mind.

Please note that the features listed below work only within scala, but not in java.

This post describes some simple hacks that allow to:
  * call methods of the referenced java object on a typed version of HGHandles. Alternatively, ultrashort parametrized dereferencing methods on regular HGHandle 
  * starting traversals as method calls on a HGHandle, using that handle as starting atom, strongly simplified by (overridable) default parameters, or parametrized as a shorthand for traversing specific Links / Siblings. Benefitting of scala's collection functions such as map/filter or intersecting different traversals.
  * pseudo-operator for quick link creation (`<->`) available after HGHandle
  * shorthands for querying the atomtypecondition of the type of the given handle, optionally combined with a further condition
  * typesafe check if handle references a HGLink using Option (can be flatMap-ed over in collection functions)
  * treat HGLink instances as collections of handles, again allowing use of wealth collections functions
  * use java objects in places where their handles are required. Alternatively, ultrashort methods on anyObject for obtaining an existing handle, assert or force add to graph.
  * calling update on a mutated object


=2.ShortDemo (currently outdated)=
{{{
val a = graph.put("hallo Welt")  
                                 // like graph.add but returning TypedHandle parametrized to String

println(a.replaceAll("hallo", "hello").replaceAll("Welt", "World")) 
                                 // prints "hello World" 
                                 // hence calling String methods directly on that typedhandle
                                 // as if it was the dereferenced java object itself

  val inc2 =  hg.findAll(graph, hg.incident("asdf"))
                                 // use objects where HGHandle are required

//
// traverse demo
//

def ++(any: Any)= graph.add(any)
val a = ++("hello")
++(new HGPlainLink(++("pink World"), a))
++(new HGPlainLink(++("screwed up World"), ++("Optimism is a lack of information.") ,"pink World".handle))
                                 // adding test data & links with ++ as shorthand for graph.add
                                 // a is a regular HGHandle that is going to be the starting atom.


a.traverse()
                                 // starting a traversal from a,
                                 // using defaults parameters (HGlink, same type etc),

a.traverse(linkConstraint = new AtomTypeCondition(classOf[HGPlainLink]))

                                 // overriding any of named default params, here specifying the Link constraint

a.traverse().map(p => p.getSecond.d[String]).map(_.toUpperCase).foreach(println)                      
                                 // mapping Pairs(linkhandle, atomhandle) to java objects
                                 // where d[T] explicitely dereferences and casts it to T

//prints:
//PINK WORLD
//OPTIMISM IS A LACK OF INFORMATION.
//SCREWED UP WORLD

    val containsWorld = a.traverse().filter(p => p.getSecond.d[String].contains("World"))
                                 // storing a traversal filtered to words contained "World"  

    def tib(dfs:Boolean) = a.traverse(linkConstraint = new AtomTypeCondition(classOf[HGPlainLink]), dfs = dfs).toSet
                                 // just a shorthand for an unfiltered traversal, which includes "Optimism is a lack of information."

tib(true).intersect(containsWorld.toSet).map(pair => pair.getSecond.d[String]).foreach(s => println("intersect: " + s))
                                 // intersecting the filtered and the unfiltered traversals using shorthand

//prints:
//intersect: pink World
//intersect: screwed up World

//but does not print: "Optimism is a lack of information."

}}}


=3. Explanations and commented scala implementation  (currently outdated)=
A HGHandle is similar to a Java object reference: it is a pointer to some data stored in memory or on disk. Although HypergraphDB atoms are strictly typed, hghandles themselves are not typed in the java world. Furthermore, since hypergraphDB does some sophisticated form of serialization, objects obtained by graph.get(somehandle) have to be cast to their respective type. 
The following hacks aim to add intuitive usage patterns, for example by treating handles as java objects (and vice versa if required).
This is achieved by introducing a class _TypedHandle_ which is simply parametrized by the type of the object that it references. Using three equally simple implicit conversions:
a) the HyperGraph class is extended to provide two methods which create/accept TypedHandle instances. 
b) TypedHandle instances are converted to the objects they references.
c) Any object can be converted to HGHandle instances, which are accepted by hypergraphDB methods requiring handles.


===TypedHandle & auto-dereferencing===
{{{
class TypedHandle[T](@BeanProperty val handle:HGHandle) extends HGPersistentHandle {
  def toByteArray = handle.getPersistent.toByteArray
  def toStringValue = handle.getPersistent.toStringValue
  def compareTo(p1: HGPersistentHandle) = handle.getPersistent.compareTo(p1)
  def getPersistent = handle.getPersistent
}

  implicit def hypergraph2richhypergraph(graph: HyperGraph) = new {
    def put[T](someObject: T): TypedHandle[T] = new TypedHandle[T](graph.add(someObject))
    def gety[T](richHandle:TypedHandle[T]):T  = graph.get(richHandle).asInstanceOf[T]   //richHandle.d(graph)
  }
    // this adds two simple methods to HyperGraph which return /accept TypedHandle

    implicit def richHandle2T[T](handle:TypedHandle[T])(implicit graph :HyperGraph):T = graph.get(handle).asInstanceOf[T]
    // treat typedhandle of T as a T 


}}}

===Hacks on HGHandle===
{{{
   implicit def richHandle(handle:HGHandle)(implicit graph :HyperGraph) = new {

    def d[T](implicit graph:HyperGraph):T = graph.get(handle).asInstanceOf[T]
        // dereference and type cast - may fail

    def ds[T](implicit graph:HyperGraph):Option[T] = try {Option(graph.get(handle).asInstanceOf[T])} catch {case _ => None}
        // save alternative of d[] using Option to flatMap / pattern match on

    def <->(handle2:HGHandle*)(implicit graph:HyperGraph):HGHandle = graph.add(new HGPlainLink(handle :: handle2.toList :_*))
        // new HGPlainLink with vararg handle2.
        // <-> as pseudo-Operator

    def newRel(relation: String, handle2:HGHandle*)(implicit graph:HyperGraph):HGHandle = graph.add(new HGRel(relation, handle :: handle2.toList :_*))
        // new HGRel

    def getType(implicit graph:HyperGraph):Class[_] = graph.getTypeSystem.getClassForType(graph.getType(handle))  // what is Class<?> / Class[_] ? that's a type constructor no?
        // get Class file of atom

    def typeAlikes(implicit graph:HyperGraph):java.util.List[HGHandle] = hg.findAll[HGHandle](graph, sameTypeQC)   //(ev.erasure))
        // return all atoms of same type

    def sameTypeQC:HGQueryCondition = new AtomTypeCondition(getType)
       // shorthand query condition of same type

    def queryOnSameType(queryCondition: HGQueryCondition)(implicit graph:HyperGraph):java.util.List[HGHandle] = hg.findAll[HGHandle](graph, hg.and(sameTypeQC, queryCondition))
        // query only on atoms of same type

    def traverse (onLink:HGAtomPredicate  = null,
                  sibling:HGAtomPredicate = null,
                  prec: Boolean = true,   suc: Boolean = true,
                  rev:  Boolean = false,  dfs: Boolean = true
                 )(implicit graph:HyperGraph):HGTraversal = {
      val alGen: HGALGenerator = new DefaultALGenerator(graph, onLink, sibling,prec, suc, rev)
      val trav: HGTraversal = if (dfs) new HGDepthFirstTraversal(handle, alGen) else new HGBreadthFirstTraversal(handle, alGen)
      trav
    }
        // start traversal departing from handle, optionally override named default params

    def typeTraverse[L <: HGLink, A] ( prec: Boolean = true,  suc: Boolean = true, rev: Boolean = false,  dfs: Boolean = true )(implicit graph:HyperGraph, evL:Manifest[L],evA:Manifest[A]):HGTraversal =
          traverse(onLink = new AtomTypeCondition(evL.erasure), sibling=new AtomTypeCondition(evA.erasure), prec =prec, suc = suc, rev=rev, dfs = dfs)(graph)
        // parametrized traversal, traverses on Links of Type L and on siblings of Type A

    def incidentLinks:java.util.List[HGHandle] = hg.findAll[HGHandle](graph, hg.incident(handle))
        // returns handles to all links pointing to this handle

    def neighbours = incidentLinks.map(linkHandle => hg.findAll[HGHandle](graph, hg.target(linkHandle)).filter(h => !h.equals(handle)))
        // returns siblings of each Link pointing to this handle

    def neighbourSet = incidentLinks.view.map(linkHandle => hg.findAll[HGHandle](graph, hg.target(linkHandle)).filter(h => !h.equals(handle))).flatten.toSet
        // returns siblings flattend into a set

    def neighbourBrothers = neighbourSet.intersect(typeAlikes.toSet)
        // intersection of type brothers in the neighbourhood

    def getLink:Option[HGLink] = try {Option(graph.get(handle).asInstanceOf[HGLink])} catch { case _ => None }
        // return an Option of HGLink referenced (or not) by handle.
  }

}}}


===Hacks on HGLink and any Object===
{{{
  //
  // HGLink hacks
  //
  implicit def link2traversable(link:HGLink)(implicit graph :HyperGraph, ev:Manifest[HGHandle]) = new IndexedSeq[HGHandle]{
    def length = link.getArity
    def apply(idx: Int) = link.getTargetAt(idx)
  }
    // implicit conversion that implements a collection trait which allows treating HGLink as a collection

  implicit def richLink(link:HGLink)(implicit graph :HyperGraph, ev:Manifest[HGHandle]) = new {
    def getPreceeding(handle:HGHandle):IndexedSeq[HGHandle]  = link.take(link.indexOf(handle))  // off-by one here?
    def getSucceeding(handle:HGHandle):IndexedSeq[HGHandle]   = link.drop(link.indexOf(handle)+1)
  }
    // two examples usages of scala collection functions on HGLink

  //
  // Hacks on any Object
  //
  implicit def pimpAny(any:Any) = new {
      def update = graph.update(any)
  // update changes to object in graph
      def h:HGHandle = graph.getHandle(any)
      def hh:HGHandle = hg.assertAtom(graph, any)
      def hhh:HGHandle = graph.add(any)
  }

}}}