#summary Benefits of using HyperGraphDB with Scala

_Disclaimer: this is user-created content and not an official HyperGraphDB document._ *Under construction*

Index
  * 1) Intro 
  * 2) ShortDemo
  * 3) Commented scala code implementing ShortDemo.


=1. Intro=
HyperGraphDB is directly usable by other JVM-languages such as Scala. Scala is interesting not only as an everyday JVM-frontend that dramatically reduces java boilerplate i.e. by implicit parameters, but also provides a versatile, powerful but no-risk toolset to use and easily adapt hypergraphDB in completely new ways, beyond mere syntactic sugar. 
For a more detailed introduction into scala and interesting features, checkout [http://scalahypergraph.blogspot.de/2012/07/interesting-scala-features.html this blogpost] written with hypergraphDB in mind.

Please note that the features listed below work only within scala, but not in java.

This post describes some simple hacks that allow to:
  * call methods of the referenced java object on a typed version of HGHandles. Alternatively, ultrashort parametrized dereferencing methods on regular HGHandle 
  * starting traversals as method calls on a HGHandle, using that handle as starting atom, strongly simplified by (overridable) default parameters, or parametrized as a shorthand for traversing specific Links / Siblings. Benefitting of scala's collection functions such as map/filter or intersecting different traversals.
  * pseudo-operator for quick link creation (`<->`) available after HGHandle
  * shorthands for querying the atomtypecondition of the type of the given handle, optionally combined with a further condition
  * typesafe check if handle references a HGLink using Option (can be flatMap-ed over in collection functions)
  * treat HGLink instances as collections of handles, again allowing use of wealth collections functions
  * use java objects in places where their handles are required. Alternatively, ultrashort methods on anyObject for obtaining an existing handle, assert or force add to graph.
  * calling update on a mutated object


=2.ShortDemo (currently outdated)=
{{{
val a = graph.put("hallo Welt")  
                                 // like graph.add but returning TypedHandle parametrized to String

println(a.replaceAll("hallo", "hello").replaceAll("Welt", "World")) 
                                 // prints "hello World" 
                                 // hence calling String methods directly on that typedhandle
                                 // as if it was the dereferenced java object itself

  val inc2 =  hg.findAll(graph, hg.incident("asdf"))
                                 // use objects where HGHandle are required

//
// traverse demo
//

def ++(any: Any)= graph.add(any)
val a = ++("hello")
++(new HGPlainLink(++("pink World"), a))
++(new HGPlainLink(++("screwed up World"), ++("Optimism is a lack of information.") ,"pink World".handle))
                                 // adding test data & links with ++ as shorthand for graph.add
                                 // a is a regular HGHandle that is going to be the starting atom.


a.traverse()
                                 // starting a traversal from a,
                                 // using defaults parameters (HGlink, same type etc),

a.traverse(linkConstraint = new AtomTypeCondition(classOf[HGPlainLink]))

                                 // overriding any of named default params, here specifying the Link constraint

a.traverse().map(p => p.getSecond.d[String]).map(_.toUpperCase).foreach(println)                      
                                 // mapping Pairs(linkhandle, atomhandle) to java objects
                                 // where d[T] explicitely dereferences and casts it to T

//prints:
//PINK WORLD
//OPTIMISM IS A LACK OF INFORMATION.
//SCREWED UP WORLD

    val containsWorld = a.traverse().filter(p => p.getSecond.d[String].contains("World"))
                                 // storing a traversal filtered to words contained "World"  

    def tib(dfs:Boolean) = a.traverse(linkConstraint = new AtomTypeCondition(classOf[HGPlainLink]), dfs = dfs).toSet
                                 // just a shorthand for an unfiltered traversal, which includes "Optimism is a lack of information."

tib(true).intersect(containsWorld.toSet).map(pair => pair.getSecond.d[String]).foreach(s => println("intersect: " + s))
                                 // intersecting the filtered and the unfiltered traversals using shorthand

//prints:
//intersect: pink World
//intersect: screwed up World

//but does not print: "Optimism is a lack of information."

}}}


=3. Explanations and commented scala implementation  (currently outdated)=
A HGHandle is similar to a Java object reference: it is a pointer to some data stored in memory or on disk. Although HypergraphDB atoms are strictly typed, hghandles themselves are not typed in the java world. Furthermore, since hypergraphDB does some sophisticated form of serialization, objects obtained by graph.get(somehandle) have to be cast to their respective type. 
The following hacks aim to add intuitive usage patterns, for example by treating handles as java objects (and vice versa if required).
This is achieved by introducing a class _TypedHandle_ which is simply parametrized by the type of the object that it references. Using three equally simple implicit conversions:
a) the HyperGraph class is extended to provide two methods which create/accept TypedHandle instances. 
b) TypedHandle instances are converted to the objects they references.
c) Any object can be converted to HGHandle instances, which are accepted by hypergraphDB methods requiring handles.

{{{
class TypedHandle[T](@BeanProperty val handle:HGHandle) extends HGPersistentHandle {
  def toByteArray = handle.getPersistent.toByteArray
  def toStringValue = handle.getPersistent.toStringValue
  def compareTo(p1: HGPersistentHandle) = handle.getPersistent.compareTo(p1)
  def getPersistent = handle.getPersistent
}

// following Test object contains the required implicit conversions, which must be in scope:

object Test extends App{
  implicit val graph = // get your HyperGraph instance here.

//
// IMPLICIT CONVERSIONS
//

// extending HyperGraph with two methods for RichHandles:
  implicit def hypergraph2richhypergraph(graph: HyperGraph) = new {
    def put[T](someObject: T): TypedHandle[T] = new TypedHandle[T](graph.add(someObject))
    def gety[T](richHandle:TypedHandle[T]):T = graph.get(richHandle).asInstanceOf[T] //richHandle.d(graph)
  }

// conversion of TypedHandle[T] to T:
  implicit def handle2T[T](handle:TypedHandle[T])(implicit graph:HyperGraph):T = graph.get(handle).asInstanceOf[T]

//hacks on HGHandle
 implicit def richHandle[T](handle:HGHandle)(implicit graph :HyperGraph, ev:Manifest[HGHandle]) = new {
    def sameType:java.util.List[HGHandle] = hg.findAll[HGHandle](graph, new AtomTypeCondition(ev.erasure))
    def sameTypeAnd(queryCondition: HGQueryCondition):java.util.List[HGHandle] = hg.findAll[HGHandle](graph, hg.and(new AtomTypeCondition(ev.erasure), queryCondition))
    def traverse (linkConstraint:HGQueryCondition = new AtomTypeCondition(classOf[HGLink]), atomConstraint:HGQueryCondition= new AtomTypeCondition(classOf[String]), returnPreceeding: Boolean = false, returnSucceeding: Boolean = true, reverseOrder: Boolean = false, dfs: Boolean = true):HGTraversal = {
      val alGen: HGALGenerator = new DefaultALGenerator()//new DefaultALGenerator(graph, linkConstraint, atomConstraint,returnPreceeding, returnSucceeding, reverseOrder)
      val trav: HGTraversal = if (dfs) new HGDepthFirstTraversal(handle, alGen) else new HGBreadthFirstTraversal(handle, alGen)
      trav
    }
    def incidentLinks:java.util.List[HGHandle] = hg.findAll[HGHandle](graph, hg.incident(handle))
    def targets:java.util.List[HGHandle]= hg.findAll[HGHandle](graph, hg.target(handle))
    def isOfType[T]:Boolean = graph.getTypeSystem.getAtomType(handle).getClass.equals(classOf[T])
    //def lowerThanThis(path:String):java.util.List[HGHandle]=  
    def d[T]:T = graph.get(handle).asInstanceOf[T]
  }

// conversion of T to HGHandle
implicit def any2handle[T](any:Any)(unique: Boolean = false)(implicit graph:HyperGraph):HGHandle = try {graph.getHandle(any) }  catch {case _ => if (!unique) graph.add(any) else hg.assertAtom(graph, any)}



graph.close
}
}}}