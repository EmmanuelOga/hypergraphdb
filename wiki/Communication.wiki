#summary HGDB communication

= Introduction =

This document is intended to describe the communication primitives that are used in the HGDB peer system.

The general principles the communication is built upon are:
  # All communication is done asynchronously.
  # Peers do not control each other, but each peer should be implemented so that it maximizes the output of the system. Workers should actually compete for jobs instead of clients competing for resources

= Use cases =

==Peer i wants to save an atom (main flow)==
1. Peer i sends a *call-for-proposal* to peer j.

{{{
 (cfp
  :sender (peer i)
  :receiver (peer j)
  :on-behalf-of (peer i)
  :content
   (action remember actionID1 advertisement)
  :ontology ontology_name
 )
}}}

_on-behalf-of_ allows peers to forward cfps to other known peers based on their knowledge of the network topology

_advertisement_ is a representation of the atom that allows peers to take an informed decision about their ability to send a *proposal* in response to this *call-for-proposal*. The form and meaning of the advertisement is described by the ontology and should be domain specific.

2. Peer j receives the call for proposal and decides to do one of the following: *propose* to peer i to store the atom or forward the message and send an *inform* message to peer i (this can be used by peer i to determine if the request is still propagating or must be resent)

The propose message has the following form:

{{{
 (propose
  :sender (peer j)
  :receiver (peer i)
  :in-reply-to actionID1
  :content
   (action remember actionID2 advertisement)
  :ontology ontology_name
 )
}}}

_in-reply-to_ identifies the call for proposal that is answered

_advertisement_ contains information about the proposal value in the defined ontology. Multiple peers may decide to compete on this call for proposal and peer i needs to take a decision.

3. Peer i receives the proposal and can decide to accept or reject it. In the first case (accept) the message sent to peer j will also contain the data required by peer j to complete the operation. In the second case (reject) a message is sent to peer j containing the reason for rejection (this reason can be used by peer j to improve his knowledge on the network, and make better proposals next time)

One of the following messages is sent:

{{{
 (accept-proposal
  :sender (peer i)
  :receiver (peer j)
  :in-reply-to actionID2
  :content
   (action remember missing_data)
 )
}}}

{{{
 (reject-proposal
  :sender (peer i)
  :receiver (peer j)
  :in-reply-to actionID2
  :content 
   (reason)
  :ontology ontology_name
 )
}}}


When peer i sends the *accept-proposal* message, peer j might fail to complete the task for various reasons. In this case peer i will try to accept other proposals or store the atom in local cache and retry at a later time.


== Peer i wants to get an atom with a given handle ==

Given a handle one can make no assumption on the location of the data. One reason for this is that we will eventually offer a load balancing mechanism that will move atoms between peers and, as such, the handle will be a location independent identifier for an atom.
This can be a scalability issue if a search of the entire network is performed every time a handle is requested, but the network will have to organize such that handles that are likely to be requested by peer i are very "close" to peer i (ideally on peer i).

The mechanism to retrieve an atom is similar to that of adding one: a *request-for-proposal* is published, in this case the action is _return_ and the advertisement is the handle.

Usually an atom should be on a single peer but we should not assume that as various failure scenarios may introduce split brain conditions or other inconsistent state. 
A peer that has the atom will send a proposal that will include as advertisement a version, a summary of the atom or the atom it self. Peer j might choose to accept or reject (and provide a reason) the proposal.

A scenario to consider here is the one in which peer i queries for an atom that does not exist (might have been deleted, might have never existed, or the peer hosting it may no longer be running). In this case no one would respond to the *call-for-proposal*. For the time being we can assume a timeout for each query, but more complex behavior might be worth considering. 