#summary The Framework for Communication Activities

= Introduction =

HyperGraph peers communicate through structured messages following a broad communication framework based on the Agent Communication Language (ACL) established by the FIPA standard (see http://www.fipa.org), which itself evolved from the Knowledge Query and Manipulation Language (KQML - see http://www.cs.umbc.edu/kqml/). In essence, the message framework defines a set of communication (or speech) acts that roughly formalise the intention of the communicating agent. 

Following the agent metaphor, conceptually each communication act is performed within the context of accomplishing a given goal (or task). The "desire" to accomplish such a goal is always going to be initiated by one of the peers. The context of communication between peers is captured as an _activity_. Each such activity has a local representation at each peer participating in it, and is identified by a UUID (Universally Unique Identifier). 

Thus, peers perform tasks (i.e. accomplish goals) by running asynchronous activities locally and communicating their state and results via speech act messages. The flow of those activities is orchestrated by a framework that provides the following elements:

  # A peer-to-peer infrastructure based on the JXTA framework (see https://jxta.dev.java.net/), including peer discovery and relay communication over firewalls.
  # Message formatting and parsing using JSON syntax (see http://www.json.org). Serialization for common HyperGraphDB objects and Java beans is implemented and it is possible to plug in custom object serialization.
  # Pluggable behaviour in the form of `BootstrapPeer` implementations
  # Management and scheduling of activities. Activities can be implemented either as "roll your own" general message handlers or as framework-managed finite-state machines. Activities can also be in a parent-child relationship. 
  # A set of predefined services such as replication and a straightforward client-server access to HyperGraphDB instances.
 
Each activity is always in one and only _workflow_ state. The framework mandates the use of a few basic states and allows for the definition of an arbitrary number of custom ones.

The implementation uses two base concepts: *tasks* and *conversations*. Both are *activities* - basically finite state machines.

A *task* manages multiple conversations and the transitions between states are triggered by changes in the states of the conversations. A *conversation* is established between exactly two peers and the transitions between states is done by either having one peer explicitly calling a method (the "say" transitions) or by receiving a message from the other peer (the "hear" transitions).

Characteristics of conversations:

  # All messages need to arrive in the "proper" order. If any out-of-order messages are received a "do-not-understand" reply is generated.
  # They are not strictly related to an action. The conversation only imposes the ordering of the performatives that are being exchanged. That being said, there can be special purpose conversation types that can be used only for a certain action.
  # Conversations should be designed with composability in mind, but even composed conversations will assume a strict order of the messages.

Characteristics of tasks:

  # The transition of a task are determined by changes in the states of the conversations handled by the task. These changes can happen when the activity is not in an appropriate state to handle them. The task must make sure that these changes are available if the state changes.
  # It is the responsibility of the conversations to ensure that no state change happens while the conversation is in a wait state at a task. This is easily ensured by the strict ordering presumption made for conversations.
  # Implementors of the Task base class will see a serialized version of the changes that happened in the conversations (they will not observe a change in a conversation while handling a change in another conversation). There is no specific need for ordering the events, but eventually it would be useful for implementors to declare a priority based ordering of the conversations state changes (in the first use case above, the propose message is more important than the inform message).