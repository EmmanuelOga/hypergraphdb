#summary Information on the experimental hazelcast storage implementation

*Disclaimer: experimental code, not production-ready. Be sure to read section Issues/Current Limitations*

= Introduction =
This page provides basic info about an experimental HypergraphDB storage implementation based on the java data/processing grid [http://www.hazelcast.com/ Hazelcast]. Hazelcast offers a plethora of advanced features and a good performance, all while being easy to use. 
The Hazelcast storage implementation -from now on called *"Hazelstore"*- allows to share a read/write hypergraphDB database by forming a peer-to-peer network with backups and auto-failover, but without central servers and without single points of failure. Since data is both distributed and partitioned, in theory the size of the HypergraphDB database can be much larger than the amount of RAM or even the diskspace available on a single cluster member.
Hazelstore was designed such that number of network hops and amount of data transferred over the network are minimal. Furthermore, in the constrains of the contract, an asynchronous mode allows operations that do not return values to immediately return without waiting for the network (for example index.addEntry/removeEntry).


= Setup and Basic Usage =
Usage of HypergraphDB with Hazelstore is simple. Checkout latest trunk from subversion, add the Hazelcast jar and scala to your classpath, and use use it like this:

{{{
    val graph = new HyperGraph()
    val config = new HGConfiguration
    config.setTransactional(false)
    config.setStoreImplementation(new Hazelstore3)
   graph.setConfit(config)
}}}

Some examples of performance-related options of Hazelcast worth exploring:
{{{
  val hazelconf = new HazelStoreConfig()
  hazelconf.setTransactional(false)
  hazelconf.getHazelConfig.setLiteMember(true)  // node is a P2P client only
  val join = hazelconf.getHazelConfig.getNetworkConfig.getJoin
  join.getMulticastConfig.setEnabled(false)
  join.getTcpIpConfig.setEnabled(true)
  .addAddress(new Address("192.168.1.2",5701))
  .addAddress(new Address("192.168.1.3",5701))
  hazelconf.getHazelConfig.getNetworkConfig.getAsymmetricEncryptionConfig
  val someIndexConf = hazelconf.getHazelConfig.getMapConfig("someIndex")
  someIndexConf.getNearCacheConfig.setInvalidateOnChange(true).setMaxIdleSeconds(100)
  someIndexConf.setBackupCount(0).setAsyncBackupCount(1)

  val hs = new Hazelstore3(hazelconf)
  val config:HGConfiguration = new HGConfiguration
  config.setStoreImplementation(hs)
  config.setTransactional(false)
  graph.setConfig(config)
  graph.open("anyString")
  graph.add(...)
  // no closing of resultset, no try/finally, no shutdown necessary
}}}


= Status & current Limitations =
 # Hazelstore is not ready for production, it does not yet pass the HypergraphDB tests. 
 # Expect bugggs!
 # Hazelstore allows to instantiate and work with HypergraphDB, and to reopen HypergraphDB opened by another cluster member.
 # Currently there is no support for transactions, since Hazelcast does not provide 2-phase-commit / XA transactions. While XA is planned for next Hazelcast version 3, it cannot be garantueed Hazelstore will ever have transactions. It is likely that there will be some transaction support but with greatly reduced performance.
 # Hazelstore does currently not yet provide persistence to disk, but only "persistence" to the cluster - it is as of yet purely in-memory! 
However, here are some detailed descriptions including code necessary for persisting your clustered hypergraphDB:
|| Persistence|| link||
|| MongoDB||http://blog.codepoly.com/hazelcast-and-mongodb||
||HBase || http://blog.codepoly.com/distribute-with-hazelcast-persist-into-hbase||
|| SimpleDB || http://blog.codepoly.com/integrating-hazelcast-and-simpledb ||
|| Amazon EC2/AWS || http://blog.codepoly.com/distribute-your-data-over-amazon-ec2-by-hazel ||
