#summary Atom types

== HyperGraphDB is a Typed World ==

Every value stored in HyperGraphDB is typed. All programming languages and database systems have types in one form or another, but what sets HyperGraphDB apart is that types themselves are atoms in the graph just like regular data. This makes HyperGraphDB into a reflexive database. So the type of every atom is also an atom and, as all atoms, is identified with a `HGHandle`, it is indexed, cached, can participate in graph relationships etc. The HGDB type is a different entity than the Java class of an atom. In fact, the Java class of an atom and the HGDB type of the same atom can be completely unrelated. However, in practice there is a correspondence between the two in that to most Java classes with instances stored as HGDB atoms, by default there are HGDB types that manage the low-level storage. And in most cases in practice you don't even need to know the `HGHandle` of an atom's type since the API in general accepts a Java `Class` and looks up the corresponding HGDB type automatically. Understanding the details of the typing system is not essential for most uses of HGDB, but it is always helpful to have a general intuition of how things work in a piece of software so we present a brief introduction here.

When you add an atom with code like this:

{{{
A a = new A(....);
graph.add(a);
}}}

the first thing the system does is try to find out whether there's a HGDB type corresponding to the Java class `A`. And if there is already a HGDB type associated with the class `A` it will simply use it. If not, it will create such a type and store it as a new _type atom_ before continuing with the storage of `a`. This new atom type will be henceforth associated with the Java class `A.class` and reused when more instances of this classes are added to the graph. To obtain the handle of the HGDB type corresponding to a Java class, you can make the following call:

{{{
HGHandle handleA = graph.getTypeSystem().getTypeHandle(A.class);
}}}

Types are implementations of the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/type/HGAtomType.html HGAtomType] interface. The main responsibilities of an `HGAtomType` implementation are storage and retrieval of concrete run-time instances. There are predefined implementations to handle Java POJOs, arrays, collections and maps. 

If you want to store a Java objects that is neither serializable, nor does it follow the Java Beans naming conventions to expose its state, then you will need to develop a custom type for that Java class. Developing a custom type is actually not hard at all - see the [RefCustomTypes writing a custom type] topic.