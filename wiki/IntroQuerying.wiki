#summary Querying in HyperGraphDB.

There is no special purpose query language for HyperGraphDB, yet. Therefore, querying for atoms is performed with a special purpose API. Like in many other database systems, the API is based on conditional expressions that you create, submit to the query system and get back a set of atoms as the result. 

== Query API Overview ==

The conditional expressions for querying are build up out of classes in the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/query/package-summary.html org.hypergraphdb.query package]. Some of the conditions apply to atom values (the Java object) while others apply to the graph structure (how atoms are link between each other). You can create a query condition by instantiating those classes. Here is an example:

{{{
    HGQueryCondition condition = new And(new AtomTypeCondition(Book.class), 
                                         new AtomPartCondition("author", "George Bush", ComparisonOperator.EQ));
    HGSearchResult<HGHandle> rs = graph.find(condition);
    try
    {
        while (rs.hasNext())
        {
            HGHandle current = rs.next();
            Book book = graph.get(current);
            System.out.println(book.geTitle());
        }
    }
    finally
    {
        rs.close();
    }
}}}

The condition should be self-explanatory: it asks for atoms of type Book and whose author is George Bush. The [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/query/AtomPartCondition.html AtomPartCondition] lets you constrain the value of an atom by one of its object properties.

As you can see, the result is returned in the form of  [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGSearchResult HGSearchResult] instance. Search results are basically bi-directional iterators (you go back to a previous item) that you need to close once you are done with them, similarly to a JDBC `ResultSet` object. If a search result is not closed, it will maintain locks on certain parts of the database which in turn is likely is likely to cause a deadlock in your application. 

That’s simple enough, albeit a bit verbose. But there is a much more convenient syntax to work with HyperGraphDB queries.  The [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGQuery.hg.html HGQuery.hg] class defines an extensive list of so called "factory methods" (methods that instantiate object in lieu of constructing them directly) for creating and composing condition. It also defines several more general purpose utility methods which you are encouraged to examine.

Here is the above condition rewritten in this style:

{{{
// Use Java 5 static import facility to import the HGQuery.hg 
// namespace.
import org.hypergraphdb.HGQuery.hg;

//
// Given some HyperGraph instance that has some Books added to it.
//
HyperGraph graph = new HyperGraph(tutorialHyperGraphLocation);

HGSearchResult rs = graph.find(hg.and(hg.type(Book.class), 
					        hg.eq(“author”, 
                                            “Borislav Iordanov”)));
while (rs.hasNext()) 
{ 
    Book b = hg.get(rs.next()); 
    System.out.println(“Found book: “ + b.getTitle());
}

rs.close();

}}}

This is achieved with several static methods in the nested `HGQuery.hg` class. 

You can create query objects and execute them repeatedly:

{{{
HGQuery query = HGQuery.make(hg, condition);
rs = query.execute();
//etc…
}}}

The `HGSearchResult` object is analogous to a JDBC result set – you can move forward and backwards on a result set, you need to close it after you’re done with it in order to release system resources (picture the usual finally block with the close statement in there).  The `HGSearchResult` interface is parameterized by the type of objects found in the result set. The type is usually a `HGHandle` so you need to do a `HyperGraph.get` if you want to actual object instance. Again, we recommend getting an actual object only at the point when its value is needed. Get used to keeping handles around instead of objects. If you have some class that works with a bunch of HyperGraphDB atoms as member variables, make the member variables HyperGraphDB handle, not Java object references. 