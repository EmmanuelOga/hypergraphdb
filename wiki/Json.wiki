#summary JSON Storage as Hypergraph Structures.

= Introduction =

[http://json.org JSON] became popular as an XML alternative for human readable structured communication between software components. However, lately it has been touted as a convenient storage data structure by various database systems labeled as "document-oriented databases" where a document is a JSON object stored as a blob and possibly indexed by various properties for quicker retrieval.

The *HGDB mJson* component takes a different approach in storing JSON structures and records them as graphs where each JSON primitive value is stored as a HyperGraphDB node and each object and array as HyperGraphDB link. 

The representation is based on a very small (1 source file) and concise Json library, called mJson developed in the context of the [http://sharegov.org Sharegov] project and described in the following blog entries:

  # [http://sharegov.blogspot.com/2011/06/json-library.html Sharegov JSON Library]
  # [http://sharegov.blogspot.com/2011/11/mjson-11-released.html mJson 1.1 Release]
  # [http://sharegov.org/mjson/ mJson Official Page]

= Get It = 

Maven dependency:

{{{
    <dependency>
      <groupId>org.hypergraphdb</groupId>
      <artifactId>hgdbmjson</artifactId>
      <version>1.2</version>
    </dependency>
}}}

If you're not using Maven, here are direct links to get mJson and the HGDB storage component:

  # [http://search.maven.org/remotecontent?filepath=org/sharegov/mjson/1.1/mjson-1.1.jar mjson-1.1.jar]
  # [http://www.hypergraphdb.org/maven/org/hypergraphdb/hgdbmjson/1.2/hgdbmjson-1.2.jar hgdbmjson-1.2.jar]

= Usage =

To use HyperGraphDB as a Json database, include the two jars above in your project (or the Maven dependency), create a `HyperGraph` instance as you would usually, then create an instance of a [http://www.hypergraphdb.org/docs/apps/mjson/mjson/hgdb/HyperNodeJson.html HyperNodeJson] passing in the `HyperGraph` object and use that `HyperNodeJson` object to talk to the database. Here's an example:

{{{
import static mjson.Json.*;
import mjson.hgdb.HyperNodeJson;
import org.hypergraphdb.*;

HyperNodeJson jsonNode = new HyperNodeJson(HGEnvironment.get("/tmp/hgdbjson"));

// Add a JSON object with two properties to the database
jsonNode.add(object("name", "Pedro", age, 28));

// ... later, do a lookup for all objects with name="Pedro"
// the results are returned as a Json array:
Json A = jsonNode.findAll(object("name", "Pedro"));

// delete the object with name="Pedro" and age=28:
jsonNode.remove(jsonNode.exactly(object("name", "Pedro", age, 28)));
}}}

As hinted by its name, the `HyperNodeJson` class implements the [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/HyperNode.html HyperNode] interface so it is an interface to the underlying graph as well. This means you can use it to interact with other types of atoms. Nevertheless, `HyperNodeJson` is a view of the database as a graph of JSON structures. The _Implementation_ section below gives some implementation details of this wrapper and why it is necessary to have it. In addition to all the standard `HyperNode` interface, it provides several additional methods related to the representation and covering common use cases. The methods for finding Json elements:

||*match(Json j, boolean exact)*|| Performs a pattern matching lookup return the first entity in the databases that matches _j_. The _exact_ parameter specifies whether object should be matched in full (true), or whether only the properties in the pattern should be matched. ||
||*exactly(Json j)*|| A shorthand for _match(j, true)_||
||*unique(Json j)*|| A shorthand for _match(j, false)_. This is intended for lookup of objects that are identified uniquely by a set of properties.||
||*find(Json j, boolean exact)*||Same logic as _match_ except a full HyperGraphDB [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/HGSearchResult.html HGSearchResult] is returned rather than the first match.||
||*find(Json j)*|| Shorthand for _find(j, false)_.||
||*findAll(Json j)*|| Do a _find(j, false)_ and return all results in a `List` of [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/HGHandle.html HGHandle]s.||
||*getAll(Json pattern)*||Same as _findAll(Json pattern)_ but return a `List` of `Json` entities.||

And there's a family of methods to lookup for JSON properties, represented as name/value pairs by the class [http://www.hypergraphdb.org/docs/apps/mjson/mjson/hgdb/JsonProperty.html JsonProperty]:

||*findProperty(HGHandle name, HGHandle value)*||Find the property atom with the given name (a String atom) and value (a Json atom).||
||findProperty(T1 name, T2 value) || A bunch of overloaded _findProperty_ methods that take different types of arguments (a String and a Json) and will do essentially what you would expect them.||
||findPropertyValues(HGHandle name)||Retrieve all Json values that appear in properties with the given name atom.||

All above methods have to do with searching the database and pattern matching on JSON structures. Adding entities also has several variants. And they have to do with how you decide to deal with repeated data (i.e. duplicates). One way to view a database, especially one build on HyperGraphDB, is as a knowledge base where each atom represents a unique and immutable piece of knowledge. In that view, you would not allow for duplicate data and every JSON structure (or pimitive value) that you store will have exactly one copy. You ensure unique by calling `HyperNodeJson.assertAtom` method:

{{{
Json x = array(1, 2, 3);
// The assert effectively perform an exact match lookup of
// the passed in Json and adds it to the database only when
// no data with the exact same value has been found.
HGHandle handleX = jsonNode.assertAtom(x);
// A second call of assertAtom with the same value
// will return the handle of the existing atom:
assert handleX.equals(jsonNode.assertAtom(x.dup()));
}}}

Another way to view a database is as a collection of data where each entity is unique simply by virtue of being stored independently. Every newly added HyperGraphDB atom gets its own unique `HGHandle` regardless of its value so that's easily achieved by simply using the standard `HyperNode.add` method:

{{{
Json x = object("entity", "movie", "title", "Underground");
HGHandle handleX = jsonNode.add(x);
// A second call with the same value will return a the handle
// of a newly created atom
assert !handleX.equals(jsonNode.add(x));
}}}

Now, the main advantage of storing JSON structures as a graph is that this creates an implicit index of all objects and arrays by their elements. That is, given any JSON property, you can easily find all the objects that have that property simply in virtue of the fact that the property is a node in the graph and all objects with that property are links pointing to it. And given any JSON value, primitive or not, you can quickly find all arrays that contain it. You can do such a query by pattern matching as shown above, or by first looking up the `JsonProperty` in question and then examining its incidence set. For example:

{{{
HGHandle propHandle = jsonNode.findProperty("person", object("firstName", "Pedro", "lastName", "Pena");
List<Json> L = jsonNode.getAll(hg.incident(propHandle));
}}}

Clearly, that strategy works only when Json values are unique in the database. Whenever there are duplicates, results from each duplicate have to be aggregated together in order to properly answer a query. 

So what would be the right view for the "average" application - a knowledge base or a collection of data, allowing duplicates? The answer is a mix of both. Conceptually, the question of whether a given datum should be duplicated bears on whether the data is representing distinct entities from the application domain. Distinct entities may very well yield the same representation at a certain point in a time, and be equivalent in that sense, yet without being identical. For example imagine you are storing information about job positions where a job position has a title, a salary and a boolean flag indicating whether it is vacant. You may well have two positions with identical information, yet they are distinct entities each subject to change on its own. So at a more practical level, the question of repeated data is related to the question of immutability - if a datum can change independently of other, equivalent data, then it should be stored separately. In an application, one frequently thinks in terms of _business entities_ or _business objects_ that are usually (but not always!) subject to change. And this is a sensible criteria to decide whether something should be stored as its own "record": when it is representing a real-world entity with mutable properties. Everything else is a "mere" value regardless of how complex it is as a data structure. Commonly, business objects are top-level entities in whatever nested representation one has defined as the model of the application domain. As top-level entities, they are mutable, but their components are generally immutable values. And this is the motivation behind the third way of inserting `Json` atoms into HyperGraphDB, the `HyperNodeJson.addTopLevel` method which will create a new atom for the passed in object, but recursively perform an `assertAtom` operation for each of its compnents. For example:

{{{
}}}

  Because Json primitives are immutable, it always makes sense to call `assertAtom` when storing primitives. Note that this would be approach the HyperGraphDB's own primitive type implementations take: it's a time-space tradeoff where one sacrifices insert speed for more compact storage.

= Implementation = 