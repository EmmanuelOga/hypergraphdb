#summary JSON Storage as Hypergraph Structures.

= Introduction =

[http://json.org JSON] became popular as an XML alternative for human readable structured communication between software components. However, lately it has been touted as a convenient storage data structure by various database systems labeled as "document-oriented databases" where a document is a JSON object stored as a blob and possibly indexed by various properties for quicker retrieval.

The *HGDB mJson* component takes a different approach in storing JSON structures and records them as graphs where each JSON primitive value is stored as a HyperGraphDB node and each object and array as HyperGraphDB link. 

The representation is based on a very small (1 source file) and concise Json library, called mJson developed in the context of the [http://sharegov.org Sharegov] project and described in the following blog entries:

  # [http://sharegov.blogspot.com/2011/06/json-library.html Sharegov JSON Library]
  # [http://sharegov.blogspot.com/2011/11/mjson-11-released.html mJson 1.1 Release]
  # [http://sharegov.org/mjson/ mJson Official Page]

= Get It = 

Maven dependency:

{{{
    <dependency>
      <groupId>org.hypergraphdb</groupId>
      <artifactId>hgdbmjson</artifactId>
      <version>1.2</version>
    </dependency>
}}}

If you're not using Maven, here are direct links to get mJson and the HGDB storage component:

  # [http://search.maven.org/remotecontent?filepath=org/sharegov/mjson/1.1/mjson-1.1.jar mjson-1.1.jar]
  # [http://www.hypergraphdb.org/maven/org/hypergraphdb/hgdbmjson/1.2/hgdbmjson-1.2.jar hgdbmjson-1.2.jar]

= Usage =

To use HyperGraphDB as a Json database, include the two jars above in your project (or the Maven dependency), create a `HyperGraph` instance as you would usually, then create an instance of a [http://www.hypergraphdb.org/docs/apps/mjson/mjson/hgdb/HyperNodeJson.html HyperNodeJson] passing in the `HyperGraph` object and use that `HyperNodeJson` object to talk to the database. Here's an example:

{{{
import static mjson.Json.*;
import mjson.hgdb.HyperNodeJson;
import org.hypergraphdb.*;

HyperNodeJson jsonNode = new HyperNodeJson(HGEnvironment.get("/tmp/hgdbjson"));

// Add a JSON object with two properties to the database
jsonNode.add(object("name", "Pedro", age, 28));

// ... later, do a lookup for all objects with name="Pedro"
// the results are returned as a Json array:
Json A = jsonNode.findAll(object("name", "Pedro"));

// delete the object with name="Pedro" and age=28:
jsonNode.remove(jsonNode.exactly(object("name", "Pedro", age, 28)));
}}}

As hinted by its name, the `HyperNodeJson` class implements the [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/HyperNode.html HyperNode] interface so it is an interface to the underlying graph as well. This means you can use it to interact with other types of atoms. Nevertheless, `HyperNodeJson` is a view of the database as a graph of JSON structures. The _Implementation_ section below gives some implementation details of this wrapper and why it is necessary to have it. In addition to all the standard `HyperNode` interface, it provides several additional methods related to the representation and covering common use cases. 

||*match(Json j, boolean exact)*|| Performs a pattern matching lookup return the first entity in the databases that matches _j_. The _exact_ parameter specifies whether object should be matched in full (true), or whether only the properties in the pattern should be matched. ||
||*exactly(Json j)*|| A shorthand for _match(j, true)_||
||*unique(Json j)*|| A shorthand for _match(j, false)_. This is intended for lookup of objects that are identified uniquely by a set of properties.||
||*find(Json j, boolean exact)*||Same logic as _match_ except a full HyperGraphDB [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/HGSearchResult.html HGSearchResult] is returned rather than the first match.||
||*find(Json j)*|| Shorthand for _find(j, false)_.||
||*findAll(Json j)*|| Do a _find(j, false)_ and return all results in a `List` of [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/HGHandle.html HGHandle]s.||
||*getAll(Json pattern)*||Same as _findAll(Json pattern)_ but return a `List` of `Json` entities.||

As you can see, all those method have to do with search the database and pattern matching on JSON structures. Adding entities also has several variants. And they have to do with how you decide to deal with repeated data (i.e. duplicates). One way to view a database, especially one build on HyperGraphDB, is as a knowledge base where each atom represents a unique and immutable piece of knowledge. In that view, you would not allow for duplicate data and every JSON structure (or pimitive value) that you store will have exactly one copy. You ensure unique by calling `HyperNodeJson.assertAtom` method:

{{{
Json x = array(1, 2, 3);
// The assert effectively perform an exact match lookup of
// the passed in Json and adds it to the database only when
// no data with the exact same value has been found.
HGHandle handleX = jsonNode.assertAtom(x);
// A second call of assertAtom with the same value
// will return the handle of the existing atom:
assert handleX.equals(jsonNode.assertAtom(x.dup()));
}}}

Another way to view a database is as a collection of data where each entity is unique simply by virtue of being stored independently. Every newly added HyperGraphDB atom gets its own unique `HGHandle` regardless of its value so that's easily achieved by simply using the standard `HyperNode.add` method:

{{{
Json x = object("entity", "movie", "title", "Underground");
HGHandle handleX = jsonNode.add(x);
// A second call with the same value will return a the handle
// of a newly created atom
assert !handleX.equals(jsonNode.add(x));
}}}

So what would be the right strategy for the "average" application? 
Because Json primitives are immutable, it always makes sense to call `assertAtom` when storing primitives. Note that this would be approach the HyperGraphDB's own primitive type implementations take: it's a time-space tradeoff where one sacrifices insert speed for more compact storage.

= Implementation = 