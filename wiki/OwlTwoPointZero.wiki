#summary OWL 2 Implementation

== What is OWL 2.0 ==

The Ontology Web Language (OWL) 2.0 is a semantic web standard based on Description Logics (DL). More information on the [http://www.w3.org/TR/owl2-overview/ W3C OWL 2.0 home page] as well as at the [http://en.wikipedia.org/wiki/Web_Ontology_Language OWL 2 Wikipedia topic].

== The HGDB-OWL App ==

_The code is located under the apps/owl in the codebase._

The HyperGraphDB implementation of OWL 2.0 is based on the [http://owlapi.sourceforge.net/ OWL API 2.0] which is the _de facto_ standard for OWL. The OWLAPI is made up of interfaces representing the constructs defined by the [http://www.w3.org/TR/owl2-syntax/ W3C standard] completely and faithfully. The OWLAPI itself offers a reference implementation of those interfaces where all data is in memory. The HGDB-OWL implementation is a drop-in replacement that has all data automatically and transparently persisted in a HyperGraphDB instance. 

In the same way that the default OWLAPI handles multiple ontologies at the same time, HGDB-OWL can store multiple ontologies in a single database instance. Each ontology is represented as a [http://www.hypergraphdb.org/docs/javadoc/org/hypergraphdb/atom/HGSubgraph.html HGSubgraph]. 

One can use the standard `OWLReasoner` API and any of the available reasoners such Hermit, Fact++ and Pellet. However, it must be noted that reasoners usually load all axioms into their own data structures depending on the reasoning algorithms used and a large ontology may easily blow out the memory. In other words, while HyperGraphDB will handle an unlimited data set, swapping things in out of the cache and allowing you to query arbitrarily large database, a reasoner will need everything in RAM before it can make any inference. To overcome this limitation a reasoner working directly with the database needs to be implemented, but that's a large project on its own. 

== Usage - a Quick Guide ==

You can use HGDB-OWL exclusively as an OWLAPI implementation. This approach is recommended if you want to leave the possibility open to easily switching to a different implementation. You can also write code using the HGDB API directly, for instance in order to take advantage of the querying facilities. Either way, first you start by populating with data and for this it's definitely easier to work at the OWL abstraction level.

First you need to create a HGDB-based OWLOntologyManager:

{{{
import org.hypergraphdb.app.owl.* ;
import org.semanticweb.owlapi.model.*;

HGDBOntologyRepository.setHypergraphDBLocation("/tmp/owldb");
OWLOntologyManager manager = HGDBOWLManager.createOWLOntologyManager();
}}}

This will create a new HyperGraphDB instance at _/tmp/owldb_. Note that if you don't specify a database directory before anything else, with the `HGDBOntologyRepository.setHypergraphDBLocation` method, one will be created at some random hard-coded place that you probably don't want. So don't forget to set the db directory.

After that you use the `OWLOntologyManager` as you would with the OWLAPI. So getting familiar with the OWLAPI and going through whatever tutorials you find around the internet is a good idea. Another important implementation class is the OWLDataFactory - you must use the one provided by HGDB-OWL. You can get it with `manager.getOWLDataFactory` or if you don't have a reference to the manager, use `OWLDataFactoryHGDB.getInstance()`.

{{{
}}}

== Resources ==

http://www.cse.iitb.ac.in/~comad/2009/proceedings/R3_4.pdf - could be useful in structuring the data for inference.