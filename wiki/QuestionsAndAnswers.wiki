#summary HyperGraphDB Questions and Answers

=== GUI for HyperGraphDB?===

There is no special purpose administrative GUI in the traditional sense. However, the scripting environment [http://www.kobrix.com/seco.jsp Seco] has been built entirely on top of HyperGraphDB. You can use to interact with a database instance via scripting or by creating your own admin components in the Seco canvas and/or leveraging such components that others have created.

===Can I access HyperGraphDB from multiple threads?===

Yes and in most cases you don't have to worry about it. If you are just using the basic API operations, such as get/add/remove, or doing queries via the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGQuery.hg.html HGQuery.hg] API, you are fine. This is because those operation are already run within a transaction.

However if you are iterating over a [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGSearchResult.html HGSearchResult], you need to encapsulate it into a transaction by using the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/transaction/HGTransactionManager.html HGTransactionManager] available with `HyperGraph.getTransactionManager()` of your HyperGraphDB instance.. 

===Creating a graph based on existing API===

First of all, you need to decide which of your classes represent relationships and which represent basic data. Instances of classes that represent basic data can be added into a HyperGraphDB instance without modification at all. They will simply be atoms of arity 0,  meaning that they don't point to other atoms. Classes that represent relationships need to be transformed into HyperGraphDB links, i.e. implementations of the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGLink.html HGLink] interface.

You can avoid implementing the HGLink interface if you find this is intrusive to your API, or if you are working with a 3d party API that you can't change, by using the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGValueLink.html HGValueLink] wrapper class. However, you won't be able to access the target set of your link from your Java object instance and you will have to rely on the HGValueLink API to do so. 

===Can I make any object into a link?===

You can turn any object into a hypergraph link by wrapping it up as a [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGValueLink.html HGValueLink]. This way you don't need to modify the Java class of the object. The object will be stored as the "payload" value of the link and it will still represent a relationship in the graph.

=== How can I add an object only if it doesn't exist?===

An object (i.e. a hypergraph atom) is uniquely identified only by its HGDB handle. Unlike in convetional RDBMS systems, there is no requirement to specify a primary key for an atom type. However it is common that certain properties of an atom identify it uniquely. At a minimum, its value and target set make unique. Therefore, you would add a uniquely identified object by first doing a lookup by the properties that define it uniquely and then insert into the database only if no results are returned by that lookup. This is a common pattern and consequently there's an API for it:

{{{
import org.hypergraphdb.HGQuery.hg;

Webpage x = new Webpage(...); // the object to be insert if not existing
HGHandle xHandle = hg.addUnique(a, hg.eq("url", a.getUrl());
}}}

The `hg.addUnique` method takes an atom to be added and a condition to query the database with. If the condition yields some results, the handle of the first one is returned. Otherwise the atom is added to the graph and its new handle is returned.

=== When should I use transactions? ===

All primitive operations offered by the HyperGraphDB API are automatically encapsulated in a transaction. In addition, HyperGraphDB supports nested transactions where child transactions can fail and be handled gracefully while a parent transaction still succeeds. There are three common cases where you may want to start and end a transaction yourself via the `HyperGraph.getTransactionManager()`:

  # You are iterating over a query result set yourself, instead of fetching all data in a Java collection. 
  # You have several operations that you want to treat as a unit - this is the most common case. For example, you need to insert two atoms and relationship between them and neither the atoms nor the relationship make sense individually in your data model. Wrap the three calls to `HyperGraph.add` in a transaction.
  # You have a data intensive portion of your application that adds hundreds of atoms in a loop. In this case you want to wrap those addition in a transaction for performance reasons. Here is why: when a primitive operation is performed, HyperGraphDB will create a transaction only if there is none currently in effect; otherwise, HyperGraphDB will reuse the current transaction. If you do, say, a hundred atom additions in a loop without creating a transaction, HyperGraphDB will create and commit a hundred separate transactions. This is much more expensive than creating and committing a single transaction for all hundred addition. The flip side is, of course, that either all or none of your atoms will be added.