#summary How to develop a custom type.

== Introduction ==

This topic explains the details of writing a custom type for HyperGraphDB. Every atom in HyperGraphDB has one and only one type. This create a natural partition of the atom space according to type and usually a typing constraint is the first condition one specifies in a query. In a sense, types act as a natural categorization/labeling of atoms. 

Furthermore, types define the semantics of storage of their values. Those semantics are abstracted into a general CRUD-like interface where there is one operation to write a value to storage, one operation to remove a value and one operation to construct the runtime representation of a value given a storage handle. Those are fundamental operations in many software settings. They are akin, for instance, to HTTP's POST, DELETE and GET respectively. But note that there is no _update_ operation like HTTP's PUT. The reason is that values in HyperGraphDB are immutable. On can attach a different value to an atom, but one cannot directly change a value. This means that once you obtain a value handle, you can be sure that this handle always points to the same value. As a consequence, value sharing between atoms and value caching are available to type implementation as possible optimizations.

Lastly, type implementations define a partial equality relation between their instances: the _subsumption_ relation. Subsumption means that some entity include another as a special case. In other words, A subsumes B if A is more general than B, or if B can be used whenever A can be used. We call this partial equality because if A and B subsume each other, they must be equal (though not identical of course). In type theory, a type generally has to define when two of its elements are equal. But in practice, often one wants to know whether something can be used (plugged in) in place of something else, as in a subclass of a class. So subsumption is in fact a more general concept than equality, it subsumes it so to speak and we've chosen that more general predicate as part of the core type interface in HyperGraphDB. 

== The HGAtomType Interface ==
So, here is the [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/type/HGAtomType.html HGAtomType interface]:

{{{
public interface HGAtomType extends HGGraphHolder
{
    Object make(HGPersistentHandle handle, LazyRef<HGHandle[]> targetSet, IncidenceSetRef incidenceSet);
    HGPersistentHandle store(Object instance);
    void release(HGPersistentHandle handle);
    boolean subsumes(Object general, Object specific);   
}
}}}

First, note that a `HGAtomType` is a [http://www.kobrix.com/javadocs/hgcore/org/hypergraphdb/HGGraphHolder.html HGGraphHolder] which means that each type will hold a reference to the HyperGraphDB instance to which it belongs. 

Next, the `store` and `release` methods are complimentary. The `store` method is responsible for recording the given object instance to permanent storage within the current transaction (if any) and returning the identifier of that object value. Note that you normally don't need to worry about starting a new transaction here. Transactions are created either at the application or atom management level and the `HGStore` implementation is responsible for using the current thread-bound transaction. 

The `make` method constructs a runtime object from storage. This runtime object can represent an atom or it can be simply some nested value within a complex-valued atom. In the latter case, the second and third arguments will be null and must be ignored. In the former, that is when an actual atom instance must be constructed, the second argument will contain the atom's target set and the third argument its incidence set. The target set is essential for constructing runtime `HGLink`s. Usage of the incidence set is optional and depends on type implementations. Incident links can provide information about an atom in the form of annotations, relationships etc., and a type can use that. An example is when complex object structures are represented as hypergraphs at the atom level, instead of at the low storage level. In that case, the fact that an atom is a property of another atom would be represented as a link (e.g. with a  _propertyOf_ label) and the incidence set of the parent atom will provide access to all its properties. 

Finally, the `subsumes` is simply a predicate that return _true_ if and only if its first argument is a more general entity than its second argument. Whatever "more general" means depends on the type. Usually, if this a type-constructor (i.e. the instances of this type are types as well), you'd return _true_ if the second argument is a subtype of the first argument. Otherwise, this is usually implemented using  Java's own `equals` method:

{{{
public boolean subsumes(Object general, Object specific)
{
    return general.equals(specific);
// or use HGUtils which checks for nulls and does deep comparison for arrays etc:
// return HGUtils.eq(general, specific); 
}
}}}

== The HGCompositeType Interface ==

== Adding Your Type to a HyperGraphDB Instance ==

== Associated a Type with a Java Class ==

== Removing a Type from a HyperGraphDB Instance ==

== Replacing an Existing Predefined Type ==