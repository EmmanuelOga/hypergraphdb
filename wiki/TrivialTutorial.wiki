#summary Minimalistic Getting-Started

=Is it difficult to understand, setup and use HypergraphDB?=
While with hypergraphDB you can do fancy things, the concepts behind are actually not difficult. It follows a very consistent logic. And it can be a very useful tool for normal, non-fancy things too. 
The intention of this tutorial is to prove that it is not difficult to use either.
And no, since version 1.2, it no longer is difficult to setup, since there no longer is the need for native library. If you are a developer, it now integrates with Maven and has excellent JSON support (among many other things).

=How to instantiate HyperGraphDB?=
{{{
HyperGraph graph = new HyperGraph("/home/schopenhauer/hgdbData/");
// do things. Then close it:
graph.close()
}}}
In production systems, you are recommended to ensure graph.close by wrapping code in try / finally blocks.

=How to store and retrieve data? - the trivial way=
{{{
String someObject = "Lorem ipsum";
HGHandle handle1 = graph.add(someObject);
System.out.println(graph.get(handleToSomeObject));
System.out.println(((String) graph.get(handle1)).toUpperCase());
}}}
->
Lorem ipsum
LOREM IPSUM

The second printout proves that we get a fully functional java object (it has a working toUpperCase method). This shows that hypergraphDB is not only a graph-database, but also a object-oriented database.

Ok. This is the trivial way, but is not the usual way hypergraphdb is typically used because:
  # graph.get() requires you to know the handle. This is often not the case, especially when you want data that you did not store just moments ago (hence most of the time! :-) ). Therefore most accesses typically happen by querying. 
  # If graph.add(someObject) is called more than once (for example by accident, each time you run a given program), you would end up with duplicates that can be disturbing when querying.


=How to store and retrieve data without knowning the handle? - querying basics=
This is done by querying, by using  "hg":
{{{
import org.hypergraphdb.HGQuery.hg;
}}}


We stored only one element in our database, so we would immediately find "Lorem ipsum" simply by querying for type String:
{{{
System.out.println(hg.getOne(graph, hg.type(String.class)));
}}}
-> "Lorem ipsum";


hg.getOne returns you any one matching result as a ready-to-use object, just as did graph.get. But often we have several items that match a certain criteria. We get can get those packed in a List, with hg.getAll:
In order to have two atoms, we just add the same object as above:
{{{
HGHandle handle2 = graph.add(someObject);
}}}

and then query for all Strings:
{{{
        for (Object s : hg.getAll(graph, hg.type(String.class)))
            System.out.println(s);
}}}

->
dolor sit amet
dolor sit amet

We get two results here, that happen to be distinct duplicate copies of the same data (we prove that later).

As you see, querying is generally used in one of this ways:
{{{
hg.getOne (graphInstance, QueryCondition); // ->  any one matching object.
hg.getAll (graphInstance, QueryCondition); // ->  all matching objects as a List.
}}}

where "QueryCondition" in our example is hg.type(String.class), but of course there is more.


=How to query for handles?=
Sometimes you need handles. To query for them is easy. It's the same as with getOne/getAll, but instead of h.getOne you use hg.findOne. Instead of hg.getAll, use hg.findAll. 

We use this to confirm that we created actual duplicate atoms in the "dolor sit amet" example above. We printout the handles, and check for equality with the handles obtained before: 

{{{
         for (Object s : hg.findAll(graph, hg.type(String.class)))
        {
            System.out.println(s);
            System.out.println((s.equals(handle1) || s.equals(handle2)));
        }
}}}

-> 
259b3dbd-4e4f-4566-b850-1029f99e6d1b
true
dceadb0c-318b-4249-917a-559d2f077fcc
true


=How to store data uniquely?=
Now, how to make sure that a given data is stored only once, even when -by accident or not- the data is stored twice?

{{{
String object2 = "dolor sit amet";
HGHandle noDup1 = hg.assertAtom(graph, object2);
HGHandle noDup2 = hg.assertAtom(graph, object2);  //trying hard to duplicate
System.out.println("Are those two handles duplicates, i.e. two distinct handles? : " + (!noDup1.equals(noDup2)));
}}}

-> 
"Are those two handles duplicates, i.e. two distinct handles? : false"

Note that - logically - there is a cost associated with due to checking. If you don't need unique atoms, graph.add is faster.

=Creating Links and querying for Links=

Till now there was nothing graph, only object-oriented database functionality. We also did not do particularly interesting queries.

Let's make a link and query for it:
{{{
        HGHandle duplicateLink = graph.add(new HGValueLink("duplicates!", handle1, handle2));
        List<HGHandle> dupsList = hg.findAll(graph, hg.link(handle1, handle2));
        System.out.println("querying for link returned that duplicate Link? :" + dupsList.contains(duplicateLink));
}}}
=>
querying for link returned that duplicate Link? :true

{{{
        List<HGHandle> dupsList2 = hg.findAll(graph, hg.and(hg.link(handle1, handle2), hg.eq("value", "duplicates!")));
        System.out.println("can we query for HGValueLinks with the value \"duplicates\" out of the box? :" + (dupsList2.size() >0 ));
}}}
can we query for HGValueLinks with value diplicates out of the box? :false

Well, in order to query for properties (such as value is a property of HGValueLink class), there are some- admitted- mildly complicated things:

  1) In order to be indexable and queriable, the class in question has to follow the Java Bean Convention. This roughly means:
  * for each field fieldName, there must be a getFieldName() method.
  * for each mutable field mutableField, there must be a setMutableField() method.
  * there has to be a default constructor, i.e. one that doesn't has any arguments.
  2) There is an indexing mechanism that you must first tell what it has to index. It looks complicated, but afterall you don't have to invent it, just use it :-)

HGValueLink is following the java bean convention, as you can confirm [http://code.google.com/p/hypergraphdb/source/browse/trunk/core/src/java/org/hypergraphdb/HGValueLink.java here]. 

So let's register the index for querying the "value" property of HGValueLink:

{{{
        HGHandle valueLinkTypeHandle = graph.getTypeSystem().getTypeHandle(HGValueLink.class);
        graph.getIndexManager().register(new ByPartIndexer(valueLinkTypeHandle, "value"));
        graph.runMaintenance();  // this explicitely starts the indexing process. Otherwise happens at next start.

        List<HGHandle> dupsList3 = hg.findAll(graph, hg.and(hg.link(handle1, handle2), hg.eq("value", "duplicates!")));
        System.out.println("can we query for HGValueLinks with value duplicates after registering an index? : " + (dupsList3.size() >0 && dupsList3.contains(duplicateLink)));     
}}}
=> 
can we query for HGValueLinks with value duplicates after registering an index? : true