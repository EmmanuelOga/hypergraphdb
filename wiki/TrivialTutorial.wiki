#summary Minimalistic Getting-Started

DISCLAIMER: this page is written by a User. It is not an "official" hypergraphDB document. It is continually extended.

This pages gives a short introduction on the most common tasks you will do with hypergraphdb. These tasks include creating a database, store, query and retrieve objects and links, traverse a graph and create indexes.

=Overview=
<wiki:toc max_depth="1" />

=Is it difficult to understand, setup and use HypergraphDB?=
While with hypergraphDB you can do fancy things, and while there are some things that are not directly obvious, the concepts behind HypergraphDB are actually not difficult. It follows a very consistent logic. And it can be a very useful tool for normal, non-fancy things too. 
The intention of this tutorial is to prove that generally, it is not difficult to use either, and to improve documentation on those edges where things are non-obvious.
Since version 1.2, it no longer is difficult to setup, since there no longer is the need for a native library. It now integrates with Maven and has excellent JSON support (among many other things).

=How to instantiate HyperGraphDB?= 
{{{
HyperGraph graph = new HyperGraph("/home/schopenhauer/hgdbData/");
// do things. Then close it:
graph.close()
}}}
If you manage several hypergraph instances, use HGEnvironment.get(location). Do not forget to close after usage, because that might lead to corruption.


=How to store and retrieve data? - the trivial way=
{{{
String someObject = "Lorem ipsum";
HGHandle handle1 = graph.add(someObject);
System.out.println(graph.get(handleToSomeObject));
System.out.println(((String) graph.get(handle1)).toUpperCase());
}}}
->
Lorem ipsum
LOREM IPSUM

Notes:
   * graph.add(...) returnes a "handle" with which you can access the datum directly (as seen in graph.get a line below). A handle generally is an auto-generated database ID. 
  *  using add/get to store and retrieve data is not necessarily the typical way hypergraphdb is used because:
  # graph.get() requires you to know the handle. This is often not the case, especially when you want data that you did not store just moments ago (hence most of the time! :-) ). Therefore most accesses typically happen by querying. 
  # If graph.add(someObject) is called more than once (for example by accident, each time you run a given program), you would end up with duplicates that can be disturbing when querying.
  * the second println demonstrate that we get a fully functional java object, in that case, it has a working toUpperCase method. This shows that hypergraphDB is not only a graph-database, but also a full object-oriented database.



=How to store and retrieve data without knowning the handle? - querying basics=
Querying is done conveniently by using the static helper class "hg":
{{{
import org.hypergraphdb.HGQuery.hg.*;
}}}


We stored only one element in our database, so we would immediately find "Lorem ipsum" simply by querying for type String:
{{{
System.out.println(hg.getOne(graph, hg.type(String.class)));
}}}
-> "Lorem ipsum";


hg.getOne returns you any one (of possibly many) matching result as a ready-to-use object, just as did graph.get. But often we have several items that match a certain criteria. We get can get those packed in a List, with hg.getAll:
In order to have two atoms, we just add the same object as above:
{{{
HGHandle handle2 = graph.add(someObject);
}}}

and then query for all Strings:
{{{
        for (Object s : hg.getAll(graph, hg.type(String.class)))
            System.out.println(s);
}}}

->
Lorem ipsum
Lorem ipsum

We get two results here, that happen to be distinct duplicate copies of the same data (we prove that later).

As you see, querying is generally used in one of this ways:
{{{
hg.getOne (graphInstance, QueryCondition); // ->  any one matching object.
hg.getAll (graphInstance, QueryCondition); // ->  all matching objects as a List.
}}}

where "QueryCondition" in our example is hg.type(String.class), but of course there is more.


=How to query for handles?=
Sometimes you need handles and also you do not want to dereference and deserialize all results of a query into memory. To query by returning handles is easy. It's the same as with getOne/getAll, but instead of h.getOne you use hg.findOne. Instead of hg.getAll, use hg.findAll. 

We use this to confirm that we created actual duplicate atoms in the "Lorem ipsum" example above. We printout the handles, and check for equality with the handles obtained before: 

{{{
         for (Object s : hg.findAll(graph, hg.type(String.class)))
        {
            System.out.println(s);
            System.out.println((s.equals(handle1) || s.equals(handle2)));
        }
}}}

-> 
259b3dbd-4e4f-4566-b850-1029f99e6d1b
true
dceadb0c-318b-4249-917a-559d2f077fcc
true


=How to store data uniquely?=
Now, how to make sure that a given data is stored only once, even when -by accident or not- the data is stored twice?

{{{
String object2 = "dolor sit amet";
HGHandle noDup1 = hg.assertAtom(graph, object2);
HGHandle noDup2 = hg.assertAtom(graph, object2);  //trying hard to duplicate
System.out.println("Are those two handles duplicates, i.e. two distinct handles? : " + (!noDup1.equals(noDup2)));
}}}

-> 
"Are those two handles duplicates, i.e. two distinct handles? : false"

Note that logically there is a cost associated with checking if a given datum already exists. If you don't need unique atoms, graph.add is faster.

=How to create Links and query for Links?=

Till now there was nothing graph, only object-oriented database functionality. We also did not do particularly interesting queries.

Let's make a link and query for it:
{{{
        HGHandle duplicateLink = graph.add(new HGPlainLink(handle1, handle2));
        List<HGHandle> dupsList = hg.findAll(graph, hg.link(handle1, handle2));
        System.out.println("querying for link returned that duplicate Link? :" + dupsList.contains(duplicateLink));
}}}
=>
querying for link returned that duplicate Link? :true

=How to make relationships?=
In the example above, we are created a link, but the information that the contained atoms are duplicates is silent. 
In order to create a meaningful relationsship, there is -among other ready-made links- HGRel. Since HGRel is part of a more powerful mechanism, you first define a HGRelType (which is comparable to a SQL table definition). In there you define the (~table) name, and the types of the atoms participating in the relationship. Since being duplicate or not is general, we use the Top-Type here.

{{{
        HGTypeSystem hts = graph.getTypeSystem();
        hts.getTop();
        HGHandle duplicateRelType = graph.add(new HGRelType("duplicates!", hts.getTop(), hts.getTop()));
        HGHandle hgrelDuplicateLink =graph.add(new HGRel(handle1, handle2), duplicateRelType);
  System.out.println("does handle2 have a duplicate? : " +
                hg.findAll(graph, hg.and(hg.link(handle2), hg.type(duplicateRelType))).contains(hgrelDuplicateLink));

}}}
=> does handle2 have a duplicate? : true



=How to query for properties?=
Consider you have a Bean like this:

{{{
public class Name {
    private String surname;
    public String getSurname() { return surname; }
    public void setSurname(String surname) { this.surname = surname; }

    private String firstName;
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName;  }

    public Name(){};
}
}}}

and you stored some names:
{{{
          Name b = new Name();
            b.setSurname("Hugo");
            b.setFirstName("Victor");
            graph.add(b);

            Name c = new Name();
            c.setSurname("Chavez");
            c.setFirstName("Hugo");
            graph.add(c);

            Name d = new Name();
            d.setSurname("Camus");
            d.setFirstName("Albert");
            graph.add(d);
}}}

then in this query we ask for people that 1) do have and 2) that don't have "Hugo" either as a surname or as a first name:
{{{
        List<Name> hugos = hg.getAll(graph, hg.and(hg.type(Name.class), hg.or(hg.eq("surname", "Hugo"), hg.eq("firstName", "Hugo"))));
        List<Name> noHugos = hg.getAll(graph, hg.and(hg.type(Name.class), hg.not(hg.or(hg.eq("surname", "Hugo"), hg.eq("firstName", "Hugo")))));

        for(Name n : hugos)
                System.out.println("hugo: surname:" + n.getSurname() + " . first name: " + n.getFirstName());

        for(Name n : noHugos)
            System.out.println("Not a Hugo: surname:" + n.getSurname() + " . first name: " + n.getFirstName());

}}}

output:
hugo: surname:Hugo . first name: Victor
hugo: surname:Chavez . first name: Hugo
Not a Hugo: surname:Camus . first name: Albert


=How to and why index?=
Indexing is not required for querying, but done for performance reasons. For the above example, you would define an index like this before running the query:
{{{
    HGHandle bTypeH = graph.getTypeSystem().getTypeHandle(Name.class);
        graph.getIndexManager().register(new ByPartIndexer(bTypeH, "surname"));
        graph.getIndexManager().register(new ByPartIndexer(bTypeH, "firstName"));
        graph.runMaintenance();
}}}

=How to traverse a graph in HypergraphDB?=
{{{
         String[] strings = "Look here, this is a String, that is gonna be split into words and linked together".toLowerCase().replaceAll(",", "").split("\\s+");
        HGHandle[] stringsHandles = new HGHandle[strings.length];
        for (int i = 0; i<strings.length; i++){
            stringsHandles[i] = graph.add(strings[i]);
        }
        for (int i = 0; i<strings.length; i++){

                if (i< strings.length-2){
                HGPlainLink link = new HGPlainLink(stringsHandles[i], stringsHandles[i+1], stringsHandles[i+2]);
                graph.add(link);
            }
        }
        HGALGenerator alGen = new DefaultALGenerator(graph, hg.type(HGPlainLink.class), hg.type(String.class),false, true, false);
        HGTraversal trav= new HGBreadthFirstTraversal(stringsHandles[0], alGen);
        while(trav.hasNext()){
            Pair<HGHandle, HGHandle> pair = trav.next();
            System.out.println("\nTraversing. Current word: " + graph.get(pair.getSecond()));
        }
}}}

=How and when to create custom types?=
Generally you don't have to create a custom HGDB type yourself. If you just add an object of your type to the DB, it will create a corresponding HGDB type for you. If you make that choice to let HGDB create the type, you have to provide a default constructor (that is, a constructor with zero arguments) for your class. 
If you want to create the type yourself, say because you want to optimize how the objects are stored, then for a property-based query to work you'd have to implement the HGCompositeType and HGAtomType interfaces.

=When to close, when to leave open?=
If hypergraphdb is killed before the clean shutdown process has succeeded, there might be data loss. In production systems, you are recommended to wrap your code in a try block, and ensure graph.close() in a finally block.
Since in most situations there is no real danger of ungraceful shutdown, and since opening and closing are associated with a cost, you can usually leave the database open until the application finished (see [https://groups.google.com/d/topic/hypergraphdb/GVo4rGGFQfs/discussion here]).


=Hello World Example= 

The following code should be treated as a 'Hello World' example, by providing the source to the Book example of the official tutorial. It demonstrates how a hypergraphdb can be created and how objects of type Book will be added to the database. Further it shows how a query is done.
{{{
public class Book implements Serializable{

    private String title;
    private String author;
   
    public Book() {
        super();
    }

    public Book(String title, String author) {
        super();
        this.author = author;
        this.title = title;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

}

public class HGDBCreateSample {
    public static void main(String[] args) {
        String databaseLocation = "C://hpgdb/testdb";
        HyperGraph graph = null;
        try {
            graph = new HyperGraph(databaseLocation);
            Book mybook = new Book("Critique of Pure Reason", "me");
            HGHandle bookHandle = graph.add(mybook);

            HGQueryCondition condition = new And(
                      new AtomTypeCondition(Book.class),
                      new AtomPartCondition(new String[]{"author"}, "me", ComparisonOperator.EQ));
            HGSearchResult<HGHandle> rs = graph.find(condition);    

// Queries can be defined more concisely, import HGQuery.hg.* then
hg.findAll(graph, and(type(Book.class), eq("author", "me"))

            try
            {
                while (rs.hasNext())
                {
                    HGHandle current = rs.next();
                    Book book = graph.get(current);
                    System.out.println(book.getTitle());
                }
            }
            finally
            {
                rs.close();
            }    
            
        } catch (Throwable t) {
            t.printStackTrace();
        } finally {
            graph.close();
        }
    }
}
}}}