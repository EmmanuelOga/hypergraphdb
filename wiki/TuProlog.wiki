#summary TuProlog interpreter integration with HyperGraphDB.

== What is !TuProlog ==

!TuProlog a pure Java Prolog interpreter developed developed at the University of Bologna, Italy, see its [http://alice.unibo.it/xwiki/bin/view/Tuprolog/ home page] for more information. The architecture of the interpreter is modular which makes relatively easy to extend. It also has a nice interface to Java and small memory footprint. A good, concise description of its features can be found at the [http://en.wikipedia.org/wiki/TuProlog TuProlog Wikipedia Page].

== !TuProlog + HyperGraphDB ==

The integration of !TuProlog and HyperGraphDB has the following goals:

  # Ability to store Prolog facts and rules (i.e. Prolog programs) in a !HyperGraph.
  # Ability to perform HyperGraphDB queries from Prolog. This amounts to being able to represent query conditions as Prolog terms.
  # Ability to represent hypergraph atoms as prolog terms so they participate in the unification process natively.

The idea is to work with HyperGraphDB data in a natural way, as if it was part of the Prolog  system.

== Codebase Fork ==

To achieve the stated goals, we had to fork the TuProlog codebase. The modularity of !TuProlog permits additions of _predicate libraries_ implemented in Java, but it doesn't permit pluggable implementations of the interpreter's rule base (`ClauseStore`s, in !TuProlog terms). 

== Implementation == 

=== Clause Stores === 

The implementation relies on a newly added `ClauseStoreManager` that maintains a list of `ClauseFactory`s. When a Prolog term must be translated into set of clauses to be verified (possibly one by one through backtracking), TuProlog creates a `ClauseStore` instance. The original TuProlog implementation uses the current theory stored in RAM. The modified implementation tries all factories in the clause manager and returns the result as soon as one of the factories is able to construct a clause store from the Prolog term, falling back to the default RAM implementation. 

This strategy allows arbitrary HGDB conditions to be treated as Prolog predicates and thus one can have a Prolog program backtrack through a HGDB result set. For this to work, however, an application must bind predicates to HGDB conditions explicitly so that they can be recognized by the HGDB clause factory. Code samples of this are given below. Thus, the integration provides for a very large factbase for the Prolog engine with efficient database style indexing etc.

Besides the HyperGraphDB backed clause factory, we've added a factory for arbitrary Java collections and Java maps. Usage samples below.

=== The HyperGraphDB Atom Term ===

We've added another variety of Prolog term to TuProlog in addition to the `Var` (representing variables),`Number` (representing numbers) and `Struct` (representing strings, symbols and compounds): the `HGAtomTem` which represents an atom in the HyperGraphDB instances. The `HGAtomTerm` will unify with another term `T` if 

  # `T` is also an atom term representing the same atom (the HGDB handles are equal).
  # `T` is bound to the HGDB handle (as a Java object) of the same atom.
  # `T` represents a Java object that is `Object.equals`  to the atom's value.
  # The atom is a string that is equal to the symbol represented by `T`.
  # The atom is a Prolog term the unifies with `T` (not implemented yet).

=== Prolog Terms Storage ===

HyperGraphDB types have been created to store Prolog terms. See the `alice.prolog.hgdb` package. Numbers, ground symbols and variables are represented in a trivial way by storing their values (the value of a variable is its name). Structs (compound terms) are represented as HGDB links with values the functor names.

== Usage == 